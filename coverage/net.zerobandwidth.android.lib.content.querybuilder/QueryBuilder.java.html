<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>QueryBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">net.zerobandwidth.android.lib.content.querybuilder</a> &gt; <span class="el_source">QueryBuilder.java</span></div><h1>QueryBuilder.java</h1><pre class="source lang-java linenums">package net.zerobandwidth.android.lib.content.querybuilder;

import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.net.Uri;

import java.util.Collection;

/**
 * Builds a {@link ContentResolver} query using builder-style methods, rather
 * than the standard methods, which use long lists of often-null parameters.
 *
 * &lt;p&gt;This class is supposed to do very little; the consumer should use the
 * static methods {@link #insertInto}, {@link #update}, {@link #selectFrom}, and
 * {@link #deleteFrom} to spawn instances of the various implementation classes
 * corresponding to query actions.&lt;/p&gt;
 *
 * @param &lt;I&gt; The implementation class which extends {@code QueryBuilder}. This
 *           is set explicitly in the declaration of the implementation class,
 *           and allows the superclass to provide concrete implementations of
 *           methods reusable by the descendants.
 * @param &lt;R&gt; The return type of the {@link #execute} method, which
 *           corresponds to a method in {@code ContentResolver}.
 *
 * @since zerobandwidth-net/android 0.1.7 (#39)
 */
public abstract class QueryBuilder&lt;I extends QueryBuilder, R&gt;
{
/// Inner classes //////////////////////////////////////////////////////////////

	/**
	 * Informs a consumer of {@link QueryBuilder} that it has tried to invoke
	 * the {@link QueryBuilder#execute} method without first binding to a data
	 * source. To prevent this exception, ensure that the consumer code properly
	 * supplies a data source when it calls one of the static
	 * {@code QueryBuilder} methods that instantiates a builder.
	 * @since zerobandwidth-net/android 0.1.7 (#39)
	 */
	public static class UnboundException
	extends IllegalStateException
	{
		protected static final String DEFAULT_MESSAGE =
			&quot;Caller tried to execute a query without a data source reference.&quot; ;

		public UnboundException()
<span class="fc" id="L47">		{ super(DEFAULT_MESSAGE) ; }</span>

		public UnboundException( String sMessage )
<span class="fc" id="L50">		{ super(sMessage) ; }</span>

		public UnboundException( Throwable xCause )
<span class="fc" id="L53">		{ super( DEFAULT_MESSAGE, xCause ) ; }</span>

		public UnboundException( String sMessage, Throwable xCause )
<span class="fc" id="L56">		{ super( sMessage, xCause ) ; }</span>
	}

	/**
	 * Exception thrown by {@link #execute} and {@link #executeOn} when the
	 * underlying {@link ContentResolver} query operation fails.
	 * @since zerobandwidth-net/android 0.1.7 (#39)
	 */
	public static class ExecutionException
	extends RuntimeException
	{
		protected static final String DEFAULT_MESSAGE =
			&quot;Query execution failed.&quot; ;

		public ExecutionException()
<span class="fc" id="L71">		{ super(DEFAULT_MESSAGE) ; }</span>

		public ExecutionException( String sMessage )
<span class="fc" id="L74">		{ super(sMessage) ; }</span>

		/**
		 * Creates a standard exception with a message indicating the class
		 * which failed to execute.
		 * @param cls the class which failed to execute
		 */
		public ExecutionException( Class&lt;? extends QueryBuilder&gt; cls )
<span class="fc" id="L82">		{ super( getClassMessage(cls) ) ; }</span>

		public ExecutionException( Throwable xCause )
<span class="fc" id="L85">		{ super( DEFAULT_MESSAGE, xCause ) ; }</span>

		public ExecutionException( String sMessage, Throwable xCause )
<span class="fc" id="L88">		{ super( sMessage, xCause ) ; }</span>

		/**
		 * Creates a standard exception with a message indicating the class
		 * which failed to execute.
		 * @param cls the class which failed to execute
		 * @param xCause the cause of the failure
		 */
		public ExecutionException( Class&lt;? extends QueryBuilder&gt; cls, Throwable xCause )
<span class="fc" id="L97">		{ super( getClassMessage(cls), xCause ) ; }</span>

		/**
		 * Generates an exception message based on the name of the class that
		 * failed.
		 * @param cls the class whose execution method failed
		 * @return a standard message indicating that the selected class failed
		 *  to execute
		 */
		protected static String getClassMessage( Class&lt;? extends QueryBuilder&gt; cls )
		{
<span class="fc" id="L108">			return (new StringBuilder())</span>
<span class="fc" id="L109">					.append( cls.getSimpleName() )</span>
<span class="fc" id="L110">					.append( &quot; execution failed.&quot; )</span>
<span class="fc" id="L111">					.toString()</span>
					;
		}
	}

/// Static kickoff methods (start queries of specific types) ///////////////////

	/**
	 * Kicks off construction of an insertion query.
	 * When constructing the builder in this way, the caller &lt;i&gt;must&lt;/i&gt; also
	 * call {@link #onDataSource}, or use {@link #executeOn} instead of
	 * {@link #execute}.
	 * @return an instance of the builder that handles insertion queries
	 */
	public static InsertionBuilder insert()
<span class="fc" id="L126">	{ return new InsertionBuilder() ; }</span>

	/**
	 * Kicks off construction of an insertion query.
	 * @param rslv the resolver through which the query should be executed
	 * @param uri the URI at which the query should be executed
	 * @return an instance of the builder that handles insertion queries
	 * @throws UnboundException if the data context is unusable
	 */
	public static InsertionBuilder insertInto( ContentResolver rslv, Uri uri )
	throws UnboundException
<span class="fc" id="L137">	{ return new InsertionBuilder( rslv, uri ) ; }</span>

	/**
	 * Kicks off construction of an insertion query.
	 * @param ctx a context which can provide a {@link ContentResolver}
	 * @param uri the URI at which the query should be executed
	 * @return an instance of the builder that handles insertion queries
	 * @throws UnboundException if the data context is unusable
	 */
	public static InsertionBuilder insertInto( Context ctx, Uri uri )
	throws UnboundException
<span class="fc" id="L148">	{ return new InsertionBuilder( ctx, uri ) ; }</span>

	/**
	 * Kicks off construction of an update query.
	 * When constructing the builder in this way, the caller &lt;i&gt;must&lt;/i&gt; also
	 * call {@link #onDataSource}, or use {@link #executeOn} instead of
	 * {@link #execute}.
	 * @return an instance of the builder that handles update queries
	 */
	public static UpdateBuilder update()
<span class="fc" id="L158">	{ return new UpdateBuilder() ; }</span>

	/**
	 * Kicks off construction of an update query.
	 * @param rslv the resolver through which the query should be executed
	 * @param uri the URI at which the query should be executed
	 * @return an instance of the builder that handles update queries
	 * @throws UnboundException if the data context is unusable
	 */
	public static UpdateBuilder update( ContentResolver rslv, Uri uri )
	throws UnboundException
<span class="fc" id="L169">	{ return new UpdateBuilder( rslv, uri ) ; }</span>

	/**
	 * Kicks off construction of an update query.
	 * @param ctx a context which can provide a {@link ContentResolver}
	 * @param uri the URI at which the query should be executed
	 * @return an instance of the builder that handles update queries
	 * @throws UnboundException if the data context is unusable
	 */
	public static UpdateBuilder update( Context ctx, Uri uri )
	throws UnboundException
<span class="fc" id="L180">	{ return new UpdateBuilder( ctx, uri ) ; }</span>

	/**
	 * Kicks off construction of a selection query.
	 * When constructing the builder in this way, the caller &lt;i&gt;must&lt;/i&gt; also
	 * call {@link #onDataSource}, or use {@link #executeOn} instead of
	 * {@link #execute}.
	 * @return an instance of the builder that handles selection queries
	 */
	public static SelectionBuilder select()
<span class="fc" id="L190">	{ return new SelectionBuilder() ; }</span>

	/**
	 * Kicks off construction of a selection query.
	 * @param rslv the resolver through which the query should be executed
	 * @param uri the URI at which the query should be executed
	 * @return an instance of the builder that handles selection queries
	 * @throws UnboundException if the data context is unusable
	 */
	public static SelectionBuilder selectFrom( ContentResolver rslv, Uri uri )
	throws UnboundException
<span class="fc" id="L201">	{ return new SelectionBuilder( rslv, uri ) ; }</span>
	/**
	 * Kicks off construction of a selection query.
	 * @param ctx a context which can provide a {@link ContentResolver}
	 * @param uri the URI at which the query should be executed
	 * @return an instance of the builder that handles selection queries
	 * @throws UnboundException if the data context is unusable
	 */
	public static SelectionBuilder selectFrom( Context ctx, Uri uri )
	throws UnboundException
<span class="fc" id="L211">	{ return new SelectionBuilder( ctx, uri ) ; }</span>

	/**
	 * Kicks off construction of a deletion query.
	 * When constructing the builder in this way, the caller &lt;i&gt;must&lt;/i&gt; also
	 * call {@link #onDataSource}, or use {@link #executeOn} instead of
	 * {@link #execute}.
	 * @return an instance of the builder that handles deletion queries
	 */
	public static DeletionBuilder delete()
<span class="fc" id="L221">	{ return new DeletionBuilder() ; }</span>

	/**
	 * Kicks off construction of a deletion query.
	 * @param rslv the resolver through which the query should be executed
	 * @param uri the URI at which the query should be executed
	 * @return an instance of the builder that handles deletion queries
	 * @throws UnboundException if the data context is unusable
	 */
	public static DeletionBuilder deleteFrom( ContentResolver rslv, Uri uri )
	throws UnboundException
<span class="fc" id="L232">	{ return new DeletionBuilder( rslv, uri ) ; }</span>

	/**
	 * Kicks off construction of a deletion query.
	 * @param ctx a context which can provide a {@link ContentResolver}
	 * @param uri the URI at which the query should be executed
	 * @return an instance of the builder that handles deletion queries
	 * @throws UnboundException if the data context is unusable
	 */
	public static DeletionBuilder deleteFrom( Context ctx, Uri uri )
	throws UnboundException
<span class="fc" id="L243">	{ return new DeletionBuilder( ctx, uri ) ; }</span>

/// Other static methods ///////////////////////////////////////////////////////

	/**
	 * Obtains a {@link ContentResolver} from the specified context, throwing an
	 * exception if that context is null.
	 * @param ctx a context which can provide a content resolver.
	 * @return the content resolver for the specified context
	 * @throws UnboundException if the context is null
	 */
	protected static ContentResolver getContentResolver( Context ctx )
	throws UnboundException
	{
<span class="fc bfc" id="L257" title="All 2 branches covered.">		if( ctx == null )</span>
<span class="fc" id="L258">			throw new UnboundException( &quot;Null context cannot provide resolver.&quot; ) ;</span>
<span class="fc" id="L259">		return ctx.getContentResolver() ;</span>
	}

	/**
	 * Ensures that the specified {@link ContentResolver} and {@link Uri} are
	 * non-null and usable as a data context.
	 * @throws ExecutionException if any problems occur
	 */
	protected static void validateDataContextBinding( ContentResolver rslv,
	                                                  Uri uri )
	throws QueryBuilder.UnboundException
	{
<span class="fc bfc" id="L271" title="All 2 branches covered.">		if( rslv == null )</span>
<span class="fc" id="L272">			throw new UnboundException( &quot;A content resolver is required.&quot; ) ;</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">		if( uri == null )</span>
<span class="fc" id="L274">			throw new UnboundException( &quot;A valid URI is required.&quot; ) ;</span>
<span class="fc" id="L275">	}</span>

/// Shared member fields ///////////////////////////////////////////////////////

	/** The {@link ContentResolver} to which the builder is bound. */
<span class="fc" id="L280">	protected ContentResolver m_rslv = null ;</span>

	/** The {@link Uri} to be supplied to the {@link ContentResolver}. */
<span class="fc" id="L283">	protected Uri m_uri = null ;</span>

	/**
	 * For &quot;insert&quot; and &quot;update&quot; operations, these are the values to be written.
	 */
<span class="fc" id="L288">	protected ContentValues m_valsToWrite = null ;</span>

	/**
	 * A substitute, explicit &quot;where&quot; format string, for which
	 * {@link #m_asExplicitWhereParams} provides the values.
	 */
<span class="fc" id="L294">	protected String m_sExplicitWhereFormat = null ;</span>

	/**
	 * A substitute, explicit list of &quot;where&quot; parameters, to fit the format
	 * string stored in {@link #m_sExplicitWhereFormat}.
	 */
<span class="fc" id="L300">	protected String[] m_asExplicitWhereParams = null ;</span>

/// Shared constructors ////////////////////////////////////////////////////////

	/**
	 * The default constructor; does not bind to a particular data source.
	 */
<span class="fc" id="L307">	public QueryBuilder() {}</span>

	/**
	 * A shared constructor which binds the builder to a the resolver found in
	 * the given context, and the specified URI.
	 * @param ctx a context which can provide a {@link ContentResolver}
	 * @param uri the URI at which the query should be executed
	 * @throws QueryBuilder.UnboundException if either parameter is unusable
	 */
	public QueryBuilder( Context ctx, Uri uri )
	throws QueryBuilder.UnboundException
<span class="fc" id="L318">	{ this.onDataSource( ctx, uri ) ; }</span>

	/**
	 * A shared constructor which binds the builder to a specific resolver and
	 * URI.
	 * @param rslv the resolver through which the query should be executed
	 * @param uri the URI at which the query should be executed
	 * @throws QueryBuilder.UnboundException if either parameter is unusable
	 */
	public QueryBuilder( ContentResolver rslv, Uri uri )
	throws QueryBuilder.UnboundException
<span class="fc" id="L329">	{ this.onDataSource( rslv, uri ) ; }</span>

/// Shared methods /////////////////////////////////////////////////////////////

	/**
	 * Binds the builder to a specific data context, to be used by the execution
	 * methods.
	 * @param rslv the resolver through which the query should be executed
	 * @param uri the URI at which the query should be executed
	 * @return (fluid)
	 * @throws QueryBuilder.UnboundException if either parameter is unusable
	 */
	public I onDataSource( ContentResolver rslv, Uri uri )
	throws QueryBuilder.UnboundException
	{
<span class="fc" id="L344">		validateDataContextBinding( rslv, uri ) ;</span>
<span class="fc" id="L345">		m_rslv = rslv ;</span>
<span class="fc" id="L346">		m_uri = uri ;</span>
		//noinspection unchecked - guaranteed by generic parameterization
<span class="fc" id="L348">		return (I)this ;</span>
	}

	/**
	 * Binds the builder to a specific data context, to be used by the execution
	 * methods.
	 * @param ctx a context which can provide a {@link ContentResolver}
	 * @param uri the URI at which the query should be executed
	 * @return (fluid)
	 * @throws QueryBuilder.UnboundException if either parameter is unusable
	 */
	public I onDataSource( Context ctx, Uri uri )
	throws QueryBuilder.UnboundException
<span class="fc" id="L361">	{ return this.onDataSource( getContentResolver(ctx), uri ) ; }</span>

	/**
	 * Sets values to be written as part of an &quot;insert&quot; or &quot;update&quot; operation,
	 * if applicable.
	 * @param vals the values to be written
	 * @return (fluid)
	 */
	public I setValues( ContentValues vals )
	{
<span class="fc" id="L371">		m_valsToWrite = vals ;</span>
		//noinspection unchecked - guaranteed by generic parameterization
<span class="fc" id="L373">		return (I)this ;</span>
	}

	/**
	 * Constructs an explicit &quot;where&quot; clause for a query.
	 *
	 * &lt;p&gt;The supplied string is used as-is in the underlying
	 * {@link ContentResolver} query function, and should contain only necessary
	 * columns with literal values (no variable substitutions). Based on this
	 * restriction, the collection of variable substitution sources will be set
	 * as {@code null}.&lt;/p&gt;
	 * @param sWhereClause the explicit &quot;where&quot; clause, containing only literal
	 *                     values
	 * @return (fluid)
	 */
	public I where( String sWhereClause )
	{
<span class="fc" id="L390">		m_sExplicitWhereFormat = sWhereClause ;</span>
<span class="fc" id="L391">		m_asExplicitWhereParams = null ;</span>
		//noinspection unchecked - guaranteed by generic parameterization
<span class="fc" id="L393">		return (I)this ;</span>
	}

	/**
	 * Sets the &quot;where&quot; clause format and values for a query.
	 * @param sWhereFormat the format string of the &quot;where&quot; clause, which must
	 *                     use {@code ?} for parameter substitution
	 * @param asWhereParams the parameters for the &quot;where&quot; clause, assigned to
	 *                      substitution markers in the format string
	 * @return (fluid)
	 * @see net.zerobandwidth.android.lib.content.ContentUtils#QUERY_VARIABLE_MARKER
	 */
	public I where( String sWhereFormat, String... asWhereParams )
	{
<span class="fc" id="L407">		m_sExplicitWhereFormat = sWhereFormat ;</span>
<span class="fc" id="L408">		m_asExplicitWhereParams = asWhereParams ;</span>
		//noinspection unchecked - guaranteed by generic parameterization
<span class="fc" id="L410">		return (I)this ;</span>
	}

	/**
	 * Sets the &quot;where&quot; clause format and values for a query.
	 * @param sWhereFormat the format string of the &quot;where&quot; clause, which must
	 *                     use {@code ?} for parameter substitution
	 * @param asWhereParams the parameters for the &quot;where&quot; clause, assigned to
	 *                      substitution markers in the format string
	 * @return (fluid)
	 * @see net.zerobandwidth.android.lib.content.ContentUtils#QUERY_VARIABLE_MARKER
	 */
	public I where( String sWhereFormat, Collection&lt;String&gt; asWhereParams )
	{
<span class="fc bfc" id="L424" title="All 2 branches covered.">		if( asWhereParams == null )</span>
<span class="fc" id="L425">			return this.where( sWhereFormat ) ;</span>
		else
		{
<span class="fc" id="L428">			return this.where( sWhereFormat,</span>
<span class="fc" id="L429">				asWhereParams.toArray( new String[asWhereParams.size()] ) ) ;</span>
		}
	}

	/**
	 * Creates the Android &quot;where&quot; clause format string to be passed to a
	 * {@link ContentResolver} query method.
	 * @return the &quot;where&quot; clause format string
	 */
	protected String getWhereFormat()
<span class="fc" id="L439">	{ return m_sExplicitWhereFormat ; }</span>

	/**
	 * Creates the array of &quot;where&quot; clause value substitutions to be passed to a
	 * {@link ContentResolver} query method.
	 * @return the &quot;where&quot; clause format string's parameters
	 */
	protected String[] getWhereParams()
<span class="fc" id="L447">	{ return m_asExplicitWhereParams ; }</span>

	/**
	 * Executes the query that has been built by the implementation class, using
	 * the {@link ContentResolver} and {@link Uri} to which the builder has been
	 * bound, either by the constructor, or by an invocation of
	 * {@link #onDataSource}.
	 * @return the return type appropriate to the query action
	 */
	public final R execute()
	throws UnboundException, ExecutionException
<span class="fc" id="L458">	{ return this.executeOn( this.m_rslv, this.m_uri ) ; }</span>

	/**
	 * Executes the query that has been built by the implementation class, using
	 * the supplied {@link ContentResolver} and {@link Uri}. Usually, this is
	 * not invoked directly, but is instead consumed by {@link #execute}.
	 * @param rslv the resolver through which the query should be executed
	 * @param uri the URI at which the query should be executed
	 * @return the return type appropriate to the query action
	 * @throws UnboundException if the data context binding is inadequate
	 * @throws ExecutionException if the underlying query fails
	 */
	public final R executeOn( ContentResolver rslv, Uri uri )
	throws UnboundException, ExecutionException
	{
<span class="fc" id="L473">		validateDataContextBinding( rslv, uri ) ;</span>
<span class="fc" id="L474">		try { return this.executeQuery( rslv, uri ) ; }</span>
<span class="fc" id="L475">		catch( Exception x )</span>
<span class="fc" id="L476">		{ throw new ExecutionException( this.getClass(), x ) ; }</span>
	}

	/**
	 * Executes the query that has been built by the implementation class, using
	 * the {@link ContentResolver} provided by the specified {@link Context},
	 * and the specified {@link Uri}.
	 * @param ctx a context which can provide a {@link ContentResolver}
	 * @param uri the URI at which the query should be executed
	 * @return the return type appropriate to the query action
	 * @throws UnboundException if the data context binding is inadequate
	 * @throws ExecutionException if the underlying query fails
	 */
	public final R executeOn( Context ctx, Uri uri )
	throws UnboundException, ExecutionException
<span class="fc" id="L491">	{ return this.executeOn( getContentResolver(ctx), uri ) ; }</span>

/// Abstract class specification ///////////////////////////////////////////////

	/**
	 * Consumed by {@link #execute} and {@link #executeOn} to actually carry out
	 * the operation. In the implementation class, this method should consist
	 * solely of the {@link ContentResolver} query method call, plus any other
	 * pre-checks which might be able to short-circuit the query execution.
	 * @param rslv the resolver through which the query should be executed
	 * @param uri the URI at which the query should be executed
	 * @return the return type appropriate to the query action
	 * @throws Exception if anything goes wrong
	 */
	protected abstract R executeQuery( ContentResolver rslv, Uri uri )
		throws Exception ;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span>Generated by the Android Gradle plugin 2.2.0</div></body></html>