<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SelectionBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">net.zerobandwidth.android.lib.content.querybuilder</a> &gt; <span class="el_source">SelectionBuilder.java</span></div><h1>SelectionBuilder.java</h1><pre class="source lang-java linenums">package net.zerobandwidth.android.lib.content.querybuilder;

import android.content.ContentResolver;
import android.content.Context;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;
import android.os.CancellationSignal;
import android.os.OperationCanceledException;
import android.support.annotation.RequiresApi;
import android.util.Log;

import net.zerobandwidth.android.lib.util.CollectionsZ;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Vector;

import static net.zerobandwidth.android.lib.content.ContentUtils.QUERY_ORDER_ASCENDING;

/**
 * Builds an insertion query against a given {@link ContentResolver} and
 * {@link Uri}.
 *
 * &lt;h3&gt;Examples&lt;/h3&gt;
 *
 * &lt;pre&gt;
 *     Cursor crs = QueryBuilder.selectFrom( rslv, uri )
 *             .allColumns()
 *             .where( &quot;entity_id=?&quot;, sID )
 *             .execute()
 *             ;
 * &lt;/pre&gt;
 *
 * &lt;pre&gt;
 *     Cursor crs = QueryBuilder.selectFrom( rslv, uri )
 *             .columns( &quot;entity_id&quot;, &quot;name&quot;, &quot;start_ts&quot;, &quot;stop_ts&quot; )
 *             .where( &quot;start_ts&gt;?&quot;, TimeUtils.now() )
 *             .orderBy( &quot;name&quot;, ContentUtils.QUERY_ORDER_ASCENDING )
 *             .execute()
 *             ;
 * &lt;/pre&gt;
 *
 * @since zerobandwidth-net/android 0.1.7 (#39)
 * @see net.zerobandwidth.android.lib.content.ContentUtils#QUERY_ORDER_ASCENDING
 * @see net.zerobandwidth.android.lib.content.ContentUtils#QUERY_ORDER_DESCENDING
 */
public class SelectionBuilder
extends QueryBuilder&lt;SelectionBuilder,Cursor&gt;
{
<span class="fc" id="L53">	protected static final String LOG_TAG =</span>
<span class="fc" id="L54">			SelectionBuilder.class.getSimpleName() ;</span>

	/** The columns to be included in the result set. */
<span class="fc" id="L57">	protected Vector&lt;String&gt; m_vColumns = null ;</span>

	/** The mapping of sortable columns to sorting directions, if any. */
<span class="fc" id="L60">	protected HashMap&lt;String,String&gt; m_mapSortSpec = null ;</span>

	public SelectionBuilder( ContentResolver rslv, Uri uri )
	{
<span class="fc" id="L64">		super( rslv, uri ) ;</span>
<span class="fc" id="L65">		this.initColumns().initSortSpec() ;</span>
<span class="fc" id="L66">	}</span>

	public SelectionBuilder( Context ctx, Uri uri )
	{
<span class="fc" id="L70">		super( ctx, uri ) ;</span>
<span class="fc" id="L71">		this.initColumns().initSortSpec() ;</span>
<span class="fc" id="L72">	}</span>

	public SelectionBuilder()
	{
<span class="fc" id="L76">		super() ;</span>
<span class="fc" id="L77">		this.initColumns().initSortSpec() ;</span>
<span class="fc" id="L78">	}</span>

	/**
	 * Initializes the vector of columns to be included in the result set.
	 * @return (fluid)
	 */
	protected SelectionBuilder initColumns()
	{
<span class="fc bfc" id="L86" title="All 2 branches covered.">		if( m_vColumns == null )</span>
<span class="fc" id="L87">			m_vColumns = new Vector&lt;&gt;() ;</span>
		else
<span class="fc" id="L89">			m_vColumns.clear() ;</span>
<span class="fc" id="L90">		return this ;</span>
	}

	/**
	 * Initializes the map of sortable columns to sorting directions.
	 * @return (fluid)
	 */
	protected SelectionBuilder initSortSpec()
	{
<span class="fc bfc" id="L99" title="All 2 branches covered.">		if( m_mapSortSpec == null )</span>
<span class="fc" id="L100">			m_mapSortSpec = new HashMap&lt;&gt;() ;</span>
		else
<span class="fc" id="L102">			m_mapSortSpec.clear() ;</span>
<span class="fc" id="L103">		return this ;</span>
	}

	/**
	 * Specifies that all columns should be included in the result set.
	 * This is the default behavior if left unspecified.
	 * @return (fluid)
	 */
	public SelectionBuilder allColumns()
<span class="fc" id="L112">	{ return this.initColumns() ; }</span>

	/**
	 * Sets the columns that should be included in the result set.
	 *
	 * If selecting all columns, then do not pass {@code null} to this method;
	 * use {@link #allColumns()} instead.
	 *
	 * @param asColumns the names of the columns to be included
	 * @return (fluid)
	 */
	public SelectionBuilder columns( String... asColumns )
	{
<span class="fc" id="L125">		this.initColumns() ;</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">		if( asColumns == null ) return this ;</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">		for( String sColumn : asColumns )</span>
		{
<span class="fc bfc" id="L129" title="All 2 branches covered.">			if( ! m_vColumns.contains( sColumn ) )</span>
<span class="fc" id="L130">				m_vColumns.add( sColumn ) ;</span>
		}
<span class="fc" id="L132">		return this ;</span>
	}

	/**
	 * Sets the columns that should be included in the result set.
	 *
	 * If selecting all columns, then do not pass {@code null} to this method;
	 * use {@link #allColumns()} instead.
	 *
	 * @param asColumns the names of the columns to be included
	 * @return (fluid)
	 */
	public SelectionBuilder columns( Collection&lt;String&gt; asColumns )
	{
<span class="fc bfc" id="L146" title="All 4 branches covered.">		if( asColumns == null || asColumns.isEmpty() )</span>
<span class="fc" id="L147">			return this.allColumns() ;</span>

<span class="fc" id="L149">		return this.columns(</span>
<span class="fc" id="L150">				asColumns.toArray( new String[ asColumns.size() ] ) ) ;</span>
	}

	/**
	 * Generates the list of columns to be included in the result set, as an
	 * array of strings to be passed to {@link ContentResolver#query}.
	 * @return a list of column names, or {@code null} if all columns are to be
	 *  included
	 */
	protected String[] getColumns()
	{
<span class="pc bpc" id="L161" title="1 of 4 branches missed.">		if( m_vColumns == null || m_vColumns.isEmpty() )</span>
<span class="fc" id="L162">			return null ;</span>
		else
<span class="fc" id="L164">			return m_vColumns.toArray( new String[ m_vColumns.size() ] ) ;</span>
	}

	/**
	 * Adds a sorting specification to the query.
	 * @param sColumn the column to be added to the sort specification
	 * @param sDirection the direction
	 * @return (fluid)
	 * @see net.zerobandwidth.android.lib.content.ContentUtils#QUERY_ORDER_ASCENDING
	 * @see net.zerobandwidth.android.lib.content.ContentUtils#QUERY_ORDER_DESCENDING
	 */
	public SelectionBuilder orderBy( String sColumn, String sDirection )
	{
<span class="fc" id="L177">		m_mapSortSpec.put( sColumn, sDirection ) ;</span>
<span class="fc" id="L178">		return this ;</span>
	}

	/**
	 * Adds a sorting specification to the query. This column will be sorted in
	 * ascending order.
	 * @param sColumn the column to be added to the sort specification
	 * @return (fluid)
	 */
	public SelectionBuilder orderBy( String sColumn )
<span class="fc" id="L188">	{ return this.orderBy( sColumn, QUERY_ORDER_ASCENDING ) ; }</span>

	/**
	 * Generates the selection's sort criteria as a string, to be supplied to
	 * {@link ContentResolver#query}.
	 * @return a sort specification
	 */
	protected String getSortSpecString()
	{
<span class="pc bpc" id="L197" title="1 of 4 branches missed.">		if( m_mapSortSpec == null || m_mapSortSpec.isEmpty() )</span>
<span class="fc" id="L198">			return null ;</span>
<span class="fc" id="L199">		StringBuilder sb = new StringBuilder() ;</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">		for( Map.Entry&lt;String,String&gt; spec : m_mapSortSpec.entrySet() )</span>
		{
<span class="fc bfc" id="L202" title="All 2 branches covered.">			if( sb.length() &gt; 0 ) sb.append( &quot;, &quot; ) ;</span>
<span class="fc" id="L203">			sb.append( spec.getKey() ).append( &quot; &quot; ).append( spec.getValue() ) ;</span>
<span class="fc" id="L204">		}</span>
<span class="fc" id="L205">		return sb.toString() ;</span>
	}

	/**
	 * Selects results from the data context.
	 * @return a set of results from the data context
	 */
	@Override
	public Cursor executeQuery( ContentResolver rslv, Uri uri )
	throws Exception
	{
<span class="fc" id="L216">		return rslv.query( uri,</span>
<span class="fc" id="L217">				this.getColumns(),</span>
<span class="fc" id="L218">				this.getWhereFormat(),</span>
<span class="fc" id="L219">				this.getWhereParams(),</span>
<span class="fc" id="L220">				this.getSortSpecString()</span>
			);
	}

	/**
	 * &lt;b&gt;&lt;i&gt;(API 16+)&lt;/i&gt;&lt;/b&gt; Selects results from the data context, while
	 * allowing the query to be cancelled in response to the specified signal.
	 * @param sig the signal which would cancel the query
	 * @return a set of results from the data context
	 */
	@RequiresApi(16)
	public Cursor executeOrCancel( CancellationSignal sig )
	throws UnboundException, ExecutionException
<span class="fc" id="L233">	{ return this.executeOrCancel( m_rslv, m_uri, sig ) ; }</span>

	/**
	 * &lt;b&gt;&lt;i&gt;(API 16+)&lt;/i&gt;&lt;/b&gt; Selects results from the data context, while
	 * allowing the query to be cancelled in response to the specified signal.
	 * Usually, this is not invoked directly, but is instead consumed by
	 * {@link #executeOrCancel(CancellationSignal)}.
	 * @param rslv the resolver through which the query should be executed
	 * @param uri the URI at which the query should be executed
	 * @param sig the signal which would cancel the query
	 * @return a set of results from the data context
	 * @throws UnboundException if the data context binding is inadequate
	 * @throws ExecutionException if the underlying query fails
	 */
	@RequiresApi(16)
	public Cursor executeOrCancel( ContentResolver rslv, Uri uri, CancellationSignal sig )
	throws UnboundException, ExecutionException
	{
<span class="fc" id="L251">		validateDataContextBinding( rslv, uri ) ;</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">		if( sig.isCanceled() )</span>
		{
<span class="fc" id="L254">			Log.i( LOG_TAG, &quot;Query already cancelled; returning trivially.&quot; ) ;</span>
<span class="fc" id="L255">			return null ;</span>
		}
		try
		{
<span class="fc" id="L259">			return rslv.query( uri,</span>
<span class="fc" id="L260">					this.getColumns(),</span>
<span class="fc" id="L261">					this.getWhereFormat(),</span>
<span class="fc" id="L262">					this.getWhereParams(),</span>
<span class="fc" id="L263">					this.getSortSpecString(),</span>
					sig
				);
		}
<span class="nc" id="L267">		catch( OperationCanceledException xCancel )</span>
		{
<span class="nc" id="L269">			Log.i( LOG_TAG, &quot;Query cancelled while in progress.&quot; ) ;</span>
<span class="nc" id="L270">			return null ;</span>
		}
<span class="nc" id="L272">		catch( Exception x )</span>
<span class="nc" id="L273">		{ throw new ExecutionException( LOG_TAG, x ) ; }</span>
	}

	/**
	 * Creates a bundle that describes the query itself, &lt;i&gt;not&lt;/i&gt; the result
	 * set that it would select. Used to pass the query specification across an
	 * intent broadcast, in a provider/resolver model. The schema for this
	 * bundle is consistent and is defined as follows:
	 *
	 * &lt;dl&gt;
	 *     &lt;dt&gt;{@link String} {@code uri}&lt;/dt&gt;
	 *     &lt;dd&gt;The URI at which the query is aimed.&lt;/dd&gt;
	 *     &lt;dt&gt;{@link String}[] {@code columns}&lt;/dt&gt;
	 *     &lt;dd&gt;The list of selection columns. Null implies all columns.&lt;/dd&gt;
	 *     &lt;dt&gt;{@link String} {@code where_format}&lt;/dt&gt;
	 *     &lt;dd&gt;The format string for the query's {@code WHERE} clause.&lt;/dd&gt;
	 *     &lt;dt&gt;{@link String}[] {@code where_params}&lt;/dt&gt;
	 *     &lt;dd&gt;
	 *         The list of parameters to be substituted in the query's
	 *         {@code WHERE} clause format string.
	 *     &lt;/dd&gt;
	 *     &lt;dt&gt;{@link String}[] {@code order_by_cols} &lt;i&gt;(optional)&lt;/i&gt;&lt;/dt&gt;
	 *     &lt;dd&gt;The list of columns on which the query is to be sorted.&lt;/dd&gt;
	 *     &lt;dt&gt;{@link String}[] {@code order_by_dirs} &lt;i&gt;(optional)&lt;/i&gt;&lt;/dt&gt;
	 *     &lt;dd&gt;
	 *         The list of sort directions (ascending/descending) for each
	 *         column mentioned in {@code order_by_cols}.
	 *     &lt;/dd&gt;
	 * &lt;/dl&gt;
	 *
	 * @return a bundle describing the selection query itself
	 * @since zerobandwidth-net/android 0.1.7 (#50)
	 */
	public Bundle toBundle()
	{
<span class="fc" id="L308">		Bundle bndl = new Bundle() ;</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">		bndl.putString( &quot;uri&quot;, ( this.m_uri != null ?</span>
<span class="fc" id="L310">				this.m_uri.toString() : null ) ) ;</span>
<span class="fc" id="L311">		bndl.putStringArray( &quot;columns&quot;, this.getColumns() ) ;</span>
<span class="fc" id="L312">		bndl.putString( &quot;where_format&quot;, this.getWhereFormat() ) ;</span>
<span class="fc" id="L313">		bndl.putStringArray( &quot;where_params&quot;, this.getWhereParams() ) ;</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">		if( ! this.m_mapSortSpec.isEmpty() )</span>
		{
<span class="fc" id="L316">			ArrayList&lt;String&gt; asOrderByCols = new ArrayList&lt;&gt;() ;</span>
<span class="fc" id="L317">			ArrayList&lt;String&gt; asOrderByDirs = new ArrayList&lt;&gt;() ;</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">			for( Map.Entry&lt;String,String&gt; spec : this.m_mapSortSpec.entrySet() )</span>
			{
<span class="fc" id="L320">				asOrderByCols.add( spec.getKey() ) ;</span>
<span class="fc" id="L321">				asOrderByDirs.add( spec.getValue() ) ;</span>
<span class="fc" id="L322">			}</span>
<span class="fc" id="L323">			bndl.putStringArray( &quot;order_by_cols&quot;,</span>
<span class="fc" id="L324">					CollectionsZ.of(String.class).toArray(asOrderByCols) ) ;</span>
<span class="fc" id="L325">			bndl.putStringArray( &quot;order_by_dirs&quot;,</span>
<span class="fc" id="L326">					CollectionsZ.of(String.class).toArray(asOrderByDirs) ) ;</span>
		}
<span class="fc" id="L328">		return bndl ;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span>Generated by the Android Gradle plugin 2.2.0</div></body></html>