<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SelectionBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">net.zerobandwidth.android.lib.database.querybuilder</a> &gt; <span class="el_source">SelectionBuilder.java</span></div><h1>SelectionBuilder.java</h1><pre class="source lang-java linenums">package net.zerobandwidth.android.lib.database.querybuilder;

import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.text.TextUtils;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Vector;

/**
 * Builds a SQLite {@code SELECT} query.
 *
 * &lt;h3&gt;Examples&lt;/h3&gt;
 *
 * &lt;pre&gt;
 * Cursor crsResult = QueryBuilder.selectFrom( sTableName )
 *     .allColumns()
 *     .where( &quot;entity_id=?&quot;, sID )
 *     .executeOn( db )
 *     ;
 * &lt;/pre&gt;
 *
 * &lt;pre&gt;
 * Cursor crsResult = QueryBuilder.selectFrom( sTableName )
 *     .columns( &quot;entity_id&quot;, &quot;name&quot;, &quot;start_ts&quot;, &quot;stop_ts&quot; )
 *     .where( &quot;active=? AND start_ts&gt;=?&quot;,
 *         QueryBuilder.WHERE_TRUE, SQLitePortal.now() )
 *     .groupBy( &quot;name&quot; )
 *     .orderBy( &quot;name&quot;, SelectionBuilder.ORDER_ASC )
 *     .limit( 10 )
 *     .executeOn( db )
 *     ;
 * &lt;/pre&gt;
 *
 * @since zerobandwidth-net/android 0.1.1 (#20)
 * @see SQLiteDatabase#query
 */
@SuppressWarnings( &quot;unused&quot; )                              // This is a library.
public class SelectionBuilder
extends QueryBuilder&lt;SelectionBuilder,Cursor&gt;
{
	/**
	 * Specifies that the selection should include all columns.
	 * @see #columns(String...)
	 */
<span class="fc" id="L48">	public static final String SELECT_ALL_COLUMNS = null ;</span>

	/**
	 * Specifies that a column should be ordered ascending.
	 * @see #orderBy(String, String)
	 */
	public static final String ORDER_ASC = &quot;ASC&quot; ;

	/**
	 * Specifies that a column should be ordered descending.
	 * @see #orderBy(String, String)
	 */
	public static final String ORDER_DESC = &quot;DESC&quot; ;

	/**
	 * Specifies that no result count limit should be enforced.
	 * @see #limit(int)
	 */
	public static final int NO_LIMIT = -1 ;

	protected static final String SQL_SELECT = &quot;SELECT &quot; ;

	protected static final String SQL_ALL_COLUMNS = &quot;*&quot; ;

	protected static final String SQL_FROM = &quot; FROM &quot; ;

	protected static final String SQL_GROUP_BY = &quot; GROUP BY &quot; ;

	protected static final String SQL_HAVING = &quot; HAVING &quot; ;

	protected static final String SQL_ORDER_BY = &quot; ORDER BY &quot; ;

	protected static final String SQL_ORDER_ASCENDING = &quot; ASC &quot; ;

	protected static final String SQL_ORDER_DESCENDING = &quot; DESC &quot; ;

	protected static final String SQL_LIMIT = &quot; LIMIT &quot; ;

	/** Flag specifying whether to select distinct results. */
<span class="fc" id="L87">	protected boolean m_bDistinct = false ;</span>

	/** The columns to be selected. */
<span class="fc" id="L90">	protected Vector&lt;String&gt; m_vColumns = null ;</span>

	/** The SQLite {@code GROUP BY} clause to be used, if any. */
<span class="fc" id="L93">	protected String m_sGroupBy = null ;</span>

	/** The SQLite {@code HAVING} clause to be used, if any. */
<span class="fc" id="L96">	protected String m_sHaving = null ;</span>

	/** The mapping of SQLite {@code ORDER BY} clauses and directions, if any. */
<span class="fc" id="L99">	protected HashMap&lt;String,String&gt; m_mapOrderBy = null ;</span>

	/** A limit on the number of results to be returned, if any. */
<span class="fc" id="L102">	protected int m_nLimit = NO_LIMIT ;</span>

	public SelectionBuilder( String sTableName )
	{
<span class="fc" id="L106">		super( sTableName ) ;</span>
<span class="fc" id="L107">		this.initColumns() ;</span>
<span class="fc" id="L108">		m_mapOrderBy = new HashMap&lt;&gt;() ;</span>
<span class="fc" id="L109">	}</span>

	/**
	 * Initializes the vector of columns to be shown, if limited.
	 * @return (fluid)
	 */
	protected SelectionBuilder initColumns()
	{
<span class="fc bfc" id="L117" title="All 2 branches covered.">		if( m_vColumns == null )</span>
<span class="fc" id="L118">			m_vColumns = new Vector&lt;&gt;() ;</span>
<span class="fc" id="L119">		return this ;</span>
	}

	/**
	 * Specifies whether to select distinct results.
	 * @param b {@code true} if only distinct results are desired
	 * @return (fluid)
	 */
	public SelectionBuilder distinct( boolean b )
<span class="fc" id="L128">	{ m_bDistinct = b ; return this ; }</span>

	/**
	 * Specifies that selection results should be distinct.
	 * @return (fluid)
	 */
	public SelectionBuilder distinct()
<span class="fc" id="L135">	{ return this.distinct(true) ; }</span>

	/**
	 * Specifies that all columns should be selected (default).
	 * @return (fluid)
	 */
	public SelectionBuilder allColumns()
<span class="fc" id="L142">	{ m_vColumns = null ; return this ; }</span>

	/**
	 * Sets the columns that should be returned in the selection set.
	 *
	 * If selecting all columns, then do not pass {@code null} to this method;
	 * use {@link #allColumns()} instead.
	 *
	 * @param asColumns the names of columns to be returned
	 * @return (fluid)
	 */
	public SelectionBuilder columns( String... asColumns )
	{
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">		if( asColumns == null ) // or SELECT_ALL_COLUMNS</span>
<span class="nc" id="L156">		{ m_vColumns = null ; return this ; }</span>
<span class="fc" id="L157">		this.initColumns() ;</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">		for( String sColumn : asColumns )</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">			if( ! m_vColumns.contains( sColumn ) ) m_vColumns.add( sColumn ) ;</span>
<span class="fc" id="L160">		return this ;</span>
	}

	/**
	 * Sets the columns that should be returned in the selection set.
	 *
	 * If selecting all columns, then do not pass {@code null} to this method;
	 * use {@link #allColumns()} instead.
	 *
	 * @param asColumns the names of columns to be returned
	 * @return (fluid)
	 */
	public SelectionBuilder columns( Collection&lt;String&gt; asColumns )
	{
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">		if( asColumns == null ) // or SELECT_ALL_COLUMNS</span>
<span class="nc" id="L175">		{ m_vColumns = null ; return this ; }</span>
<span class="fc" id="L176">		this.initColumns() ;</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">		for( String sColumn : asColumns )</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">			if( ! m_vColumns.contains( sColumn ) ) m_vColumns.add( sColumn ) ;</span>
<span class="fc" id="L179">		return this ;</span>
	}

	/**
	 * Generates the column list to be passed to {@link SQLiteDatabase#query}.
	 * @return a list of column names, or {@code null} if not limited.
	 */
	protected String[] getColumnList()
	{
<span class="fc bfc" id="L188" title="All 4 branches covered.">		if( m_vColumns == null || m_vColumns.isEmpty() )</span>
<span class="fc" id="L189">			return null ;</span>
		else
<span class="fc" id="L191">			return m_vColumns.toArray( new String[m_vColumns.size()] ) ;</span>
	}

	/**
	 * Specifies the SQLite {@code GROUP BY} clause for the selection.
	 * Pass {@code null} to specify no grouping.
	 * @param sGroupByClause the SQLite {@code GROUP BY} clause
	 * @return (fluid)
	 */
	public SelectionBuilder groupBy( String sGroupByClause )
<span class="fc" id="L201">	{ m_sGroupBy = sGroupByClause ; return this ; }</span>

	/**
	 * Specifies the SQLite {@code HAVING} clause for the selection.
	 * Pass {@code null} to specify no clause.
	 * @param sHavingClause the SQLite {@code HAVING} clause
	 * @return (fluid)
	 */
	public SelectionBuilder having( String sHavingClause )
<span class="nc" id="L210">	{ m_sHaving = sHavingClause ; return this ; }</span>

	/**
	 * Adds an SQLite {@code ORDER BY} clause to the selection.
	 * This method can be invoked multiple times to construct a multi-layered
	 * clause.
	 * @param sColumnName the name of the column to be sorted
	 * @param sDirection the direction of sorting
	 * @return (fluid)
	 * @see #ORDER_ASC
	 * @see #ORDER_DESC
	 */
	public SelectionBuilder orderBy( String sColumnName, String sDirection )
	{
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">		if( ! m_mapOrderBy.containsKey( sColumnName ) )</span>
<span class="fc" id="L225">			m_mapOrderBy.put( sColumnName, sDirection ) ;</span>
<span class="fc" id="L226">		return this ;</span>
	}

	/**
	 * Adds an SQLite {@code ORDER BY} clause to the selection.
	 * This method can be invoked multiple times to construct a multi-layered
	 * clause.
	 * The sorting direction set by this method is always &quot;ascending&quot;.
	 * @param sColumnName the name of the column to be sorted
	 * @return (fluid)
	 */
	public SelectionBuilder orderBy( String sColumnName )
	{
<span class="fc bfc" id="L239" title="All 2 branches covered.">		if( sColumnName == null )</span>
		{
<span class="fc" id="L241">			m_mapOrderBy.clear() ;</span>
<span class="fc" id="L242">			return this ;</span>
		}
<span class="fc" id="L244">		else return this.orderBy( sColumnName, ORDER_ASC ) ;</span>
	}

	/**
	 * Generates the selection's {@code ORDER BY} clause, if any.
	 * @return an {@code ORDER BY} clause for the selection
	 */
	protected String getOrderByClause()
	{
<span class="pc bpc" id="L253" title="1 of 4 branches missed.">		if( m_mapOrderBy == null || m_mapOrderBy.isEmpty() )</span>
<span class="fc" id="L254">			return null ;</span>
<span class="fc" id="L255">		StringBuilder sb = new StringBuilder() ;</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">		for( Map.Entry&lt;String,String&gt; o : m_mapOrderBy.entrySet() )</span>
		{
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">			if( sb.length() &gt; 0 ) sb.append( &quot;, &quot; ) ;</span>
<span class="fc" id="L259">			sb.append( o.getKey() )</span>
<span class="fc" id="L260">			  .append( &quot; &quot; )</span>
<span class="fc" id="L261">			  .append( o.getValue() )</span>
			  ;
<span class="fc" id="L263">		}</span>
<span class="fc" id="L264">		return sb.toString() ;</span>
	}

	/**
	 * Adds an SQLite {@code LIMIT} clause to the selection.
	 * To explicitly enforce no limit, pass {@link #NO_LIMIT}.
	 * @param nLimit the limit to be enforced, or {@link #NO_LIMIT} (default)
	 * @return (fluid)
	 */
	public SelectionBuilder limit( int nLimit )
<span class="fc" id="L274">	{ m_nLimit = nLimit ; return this ; }</span>

	/**
	 * Executes the selection query.
	 * @param db the database instance on which the query should be executed.
	 * @return a cursor on the result set
	 * @see SQLiteDatabase#query
	 */
	@Override
	public Cursor executeOn( SQLiteDatabase db )
	{
<span class="fc" id="L285">		return db.query(</span>
				m_bDistinct,
				m_sTableName,
<span class="fc" id="L288">				this.getColumnList(),</span>
<span class="fc" id="L289">				this.getWhereFormat(),</span>
<span class="fc" id="L290">				this.getWhereParams(),</span>
				m_sGroupBy,
				m_sHaving,
<span class="fc bfc" id="L293" title="All 2 branches covered.">				this.getOrderByClause(),</span>
<span class="fc" id="L294">				( m_nLimit == NO_LIMIT ? null : Integer.toString(m_nLimit) )</span>
			);
	}

	/**
	 * Constructs a raw SQL {@code SELECT} query based on the attributes of the
	 * builder instance.
	 * @return a raw SQLite {@code SELECT} query
	 */
	@Override
	public String toString()
	{
<span class="fc" id="L306">		StringBuilder sb = new StringBuilder() ;</span>
<span class="fc" id="L307">		sb.append( SQL_SELECT ) ;</span>
<span class="fc" id="L308">		final String[] asColumns = this.getColumnList() ;</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">		sb.append(( asColumns == null ? SQL_ALL_COLUMNS :</span>
<span class="fc" id="L310">			TextUtils.join( &quot;, &quot;, asColumns )) )</span>
		  ;
<span class="fc" id="L312">		sb.append( SQL_FROM ).append( m_sTableName ) ;</span>
<span class="fc" id="L313">		final String sWhere = this.getWhereClause() ;</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">		if( sWhere != null )</span>
<span class="fc" id="L315">			sb.append( SQL_WHERE ).append( sWhere ) ;</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">		if( m_sGroupBy != null )</span>
<span class="fc" id="L317">			sb.append( SQL_GROUP_BY ).append( m_sGroupBy ) ;</span>
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">		if( m_sHaving != null )</span>
<span class="nc" id="L319">			sb.append( SQL_HAVING ).append( m_sHaving ) ;</span>
<span class="fc" id="L320">		final String sOrderBy = this.getOrderByClause() ;</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">		if( sOrderBy != null )</span>
<span class="fc" id="L322">			sb.append( SQL_ORDER_BY ).append( sOrderBy ) ;</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">		if( m_nLimit != NO_LIMIT )</span>
<span class="fc" id="L324">			sb.append( SQL_LIMIT ).append( m_nLimit ) ;</span>
<span class="fc" id="L325">		sb.append( &quot; ;&quot; ) ;</span>
<span class="fc" id="L326">		return sb.toString() ;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span>Generated by the Android Gradle plugin 2.2.0</div></body></html>