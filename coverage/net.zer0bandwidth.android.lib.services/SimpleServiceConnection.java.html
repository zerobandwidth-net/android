<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SimpleServiceConnection.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">net.zer0bandwidth.android.lib.services</a> &gt; <span class="el_source">SimpleServiceConnection.java</span></div><h1>SimpleServiceConnection.java</h1><pre class="source lang-java linenums">package net.zer0bandwidth.android.lib.services;

import android.app.Service;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.IBinder;
import android.util.Log;

import java.util.Vector;

/**
 * This class provides a simple, consistent implementation of a service binding,
 * so that neither the service nor the consumer of that service is required to
 * have its own implementation. The class provides basic methods to bind to, and
 * unbind from, the service; get the bound instance of the service; bind as a
 * listener to the connection itself.
 *
 * Note: In version 0.1.0 (#19), the class's members and inner classes were
 * fundamentally modified to provide tighter access to the connected service
 * class. While this makes the class more convenient to use, it is a flag day
 * beyond which consumers of this class will need to be modified to catch up.
 *
 * @since zer0bandwidth-net/android 0.0.1 (#1)
 */
@SuppressWarnings(&quot;unused&quot;) // because it's a library
public class SimpleServiceConnection&lt;S extends Service&gt;
implements ServiceConnection
{
    /**
     * By default, the connection will bind at a level above the consumer, and
     * auto-create the service if it has not yet been started.
     * Used by the class's {@link #connect} methods in absence of any flag set
     * specified by the caller.
     */
    public static final int DEFAULT_BINDING_FLAGS =
            ( Context.BIND_ABOVE_CLIENT | Context.BIND_AUTO_CREATE ) ;

    /**
     * Because connections can take a while, the object that is waiting for the
     * connection to be completed should implement this interface to receive a
     * signal when the connection is established.
     * @since zer0bandwidth-net/android 0.0.1 (#1)
     */
    @SuppressWarnings(&quot;unused&quot;) // because it's still a library
    public interface Listener&lt;LS extends Service&gt;
    {
        /** Invoked when the connection is bound. */
        void onServiceConnected( SimpleServiceConnection&lt;LS&gt; conn ) ;

        /** Invoked when the connection is unbound. */
        void onServiceDisconnected( SimpleServiceConnection&lt;LS&gt; conn ) ;
    }

    /**
     * The binder provided by the service needs to implement this interface,
     * which provides us with a standard way to reach into the service's own
     * public methods.
     * @since zer0bandwidth-net/android 0.0.1 (#1)
     */
    public interface InstanceBinder&lt;BS extends Service&gt;
    extends IBinder
    {
        /** Provides the bound instance of the service. */
        BS getServiceInstance() ;
    }

    /**
     * Stores a consistent hint to the service class to which this connection
     * will bind.
     */
<span class="nc" id="L73">    protected Class&lt;S&gt; m_clsService = null ;</span>
    /** The bound instance. */
<span class="nc" id="L75">    protected S m_srvInstance = null ;</span>
    /** Indicates whether the connection is, indeed, bound to a service. */
<span class="nc" id="L77">    protected boolean m_bBound = false ;</span>
    /** A collection of objects listening to this connection. */
<span class="nc" id="L79">    protected Vector&lt;Listener&lt;S&gt;&gt; m_vListeners = null ;</span>

    /**
     * For log messages generated by methods of this class, or any descendant
     * class, use this method, which examines the class of the instance from
     * which it is called, and returns that class's simple name. This allows
     * other projects to extend this class without having to override this
     * method.
     * @return a logging tag for this connection object
     */
    protected final String getLogTag()
<span class="nc" id="L90">    { return this.getClass().getSimpleName() ; }</span>

    /** Forbid use of the default constructor. */
<span class="nc" id="L93">    private SimpleServiceConnection() {}</span>

    /**
     * Initializes a simple connection for a specified service class.
     * @param cls the service class
     */
    public SimpleServiceConnection( Class&lt;S&gt; cls )
<span class="nc" id="L100">    {</span>
<span class="nc" id="L101">        m_clsService = cls ;</span>
<span class="nc" id="L102">        this.initListeners() ;</span>
<span class="nc" id="L103">    }</span>

    /**
     * Initializes the pool of connection listeners.
     * @return the connection, for fluid invocations
     */
    protected SimpleServiceConnection&lt;S&gt; initListeners()
    {
<span class="nc bnc" id="L111" title="All 2 branches missed.">        if( m_vListeners == null )</span>
<span class="nc" id="L112">            m_vListeners = new Vector&lt;&gt;() ;</span>
        else
<span class="nc" id="L114">            m_vListeners.clear() ;</span>
<span class="nc" id="L115">        return this ;</span>
    }

    /**
     * Accesses the pool of listeners, verifying first that such a pool has been
     * initialized.
     * @return a collection of listeners to this connection
     */
    protected Vector&lt;Listener&lt;S&gt;&gt; getListeners()
    {
<span class="nc bnc" id="L125" title="All 2 branches missed.">        if( m_vListeners == null ) this.initListeners() ;</span>
<span class="nc" id="L126">        return m_vListeners ;</span>
    }

    /**
     * Registers a listener to this collection, if it is not already listening.
     * @param l the listener to be added
     * @return the connection, for fluid invocations
     */
    public SimpleServiceConnection&lt;S&gt; addListener( Listener&lt;S&gt; l )
    {
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if( ! this.getListeners().contains(l) )</span>
<span class="nc" id="L137">            m_vListeners.add(l) ;</span>
<span class="nc" id="L138">        return this ;</span>
    }

    /**
     * Unregisters a listener to this collection, if it is found in the pool.
     * @param l the listener to be removed
     * @return the connection, for fluid invocations
     */
    public SimpleServiceConnection&lt;S&gt; removeListener( Listener&lt;S&gt; l )
    {
<span class="nc bnc" id="L148" title="All 2 branches missed.">        if( this.getListeners().contains(l) )</span>
<span class="nc" id="L149">            m_vListeners.remove(l) ;</span>
<span class="nc" id="L150">        return this ;</span>
    }

    /**
     * Accessor for the service class hint.
     * @return the service class hint
     */
    public Class&lt;S&gt; getServiceClass()
<span class="nc" id="L158">    { return m_clsService ; }</span>

    /**
     * Indicates whether the connection is indeed bound to an instance of the
     * specified class.
     * @param cls the class to which we should compare our bound service
     * @return true iff the specified class is the bound service's class
     */
    public &lt;C extends Service&gt; boolean isServiceClass( Class&lt;C&gt; cls )
<span class="nc" id="L167">    { return( m_clsService.equals(cls) ) ; }</span>

    /**
     * Indicates whether the connection is bound.
     * @return an indication that the service is bound
     */
    public synchronized boolean isBound()
<span class="nc" id="L174">    { return m_bBound ; }</span>

    /**
     * Perhaps more useful than {@link #isBound}, this function verifies not
     * only that the connection is bound, but also that the persistent reference
     * to the service is not null.
     * @return an indication that the connection is, indeed, connected
     * @since zer0bandwidth-net/android 0.0.1 (#5)
     */
    public synchronized boolean isConnected()
<span class="nc bnc" id="L184" title="All 4 branches missed.">    { return ( m_bBound &amp;&amp; m_srvInstance != null ) ; }</span>

    /**
     * Accessor for the service instance, if the connection is bound.
     * @return the bound instance of the service, if any
     */
    public synchronized S getServiceInstance()
<span class="nc" id="L191">    { return m_srvInstance ; }</span>

    /**
     * Attempts to connect to the service.
     * The caller should not process the return value of this method immediately
     * in order to access the service; rather, it should handle the consequences
     * of the connection by implementing {@link Listener#onServiceConnected}.
     * @param ctx the context in which to bind to the service
     * @param bmFlags a mask of optional binding flags; see {@link Context}
     * @return the connection, for fluid invocations
     * @throws IllegalArgumentException if the context is null
     */
    public synchronized SimpleServiceConnection&lt;S&gt; connect( Context ctx, int bmFlags )
    throws IllegalArgumentException
    {
<span class="nc bnc" id="L206" title="All 2 branches missed.">        if( ctx == null )</span>
        {
<span class="nc" id="L208">            throw new IllegalArgumentException(</span>
                    &quot;Cannot bind to service from a null context.&quot; ) ;
        }
<span class="nc bnc" id="L211" title="All 2 branches missed.">        if( this.isConnected() )</span>
<span class="nc" id="L212">        { Log.d( this.getLogTag(), &quot;Already connected.&quot; ) ; }</span>
        else
        { // Bind this connection to the service.
<span class="nc" id="L215">            Intent sig = new Intent( ctx, m_clsService ) ;</span>
<span class="nc" id="L216">            ctx.bindService( sig, this, bmFlags ) ;</span>
        }
<span class="nc" id="L218">        return this ;</span>
    }

    /**
     * Attempts to connect to the service, using the default binding control
     * flags.
     * The caller should not process the return value of this method immediately
     * in order to access the service; rather, it should handle the consequences
     * of the connection by implementing {@link Listener#onServiceConnected}.
     * @param ctx the context in which to bind to the service
     * @return the connection, for fluid invocations
     * @see #DEFAULT_BINDING_FLAGS
     */
    public synchronized SimpleServiceConnection&lt;S&gt; connect( Context ctx )
<span class="nc" id="L232">    { return this.connect( ctx, DEFAULT_BINDING_FLAGS ) ; }</span>

    /**
     * Attempts to break the connection to the service. Methods that tear down
     * the context in which the service was started (such as
     * {@link android.app.Activity#onStop}) should call this method to free the
     * service binding. The caller should not assume that the binding was
     * successfully released; any other consequences of releasing this binding
     * should be handled by implementing {@link Listener#onServiceDisconnected}.
     * @param ctx the context in which the binding should be broken
     * @return the connection, for fluid invocations
     */
    public synchronized SimpleServiceConnection&lt;S&gt; disconnect( Context ctx )
    {
<span class="nc bnc" id="L246" title="All 2 branches missed.">        if( ctx == null )</span>
        { // Return trivially but log a warning.
<span class="nc" id="L248">            Log.w( this.getLogTag(), (new StringBuilder())</span>
<span class="nc" id="L249">                    .append( &quot;Cannot disconnect from service [&quot; )</span>
<span class="nc" id="L250">                    .append( m_clsService.getCanonicalName() )</span>
<span class="nc" id="L251">                    .append( &quot;] from a null context. &quot; )</span>
<span class="nc" id="L252">                    .append( &quot;A connection might be leaked!&quot; )</span>
<span class="nc" id="L253">                    .toString()</span>
                );
<span class="nc" id="L255">            return this ;</span>
        }
<span class="nc bnc" id="L257" title="All 2 branches missed.">        if( ! this.isConnected() ) return this ; // trivially</span>
<span class="nc" id="L258">        try { ctx.unbindService(this) ; }</span>
<span class="nc" id="L259">        catch( RuntimeException x ) // includes IllegalArgumentException</span>
<span class="nc" id="L260">        { Log.i( this.getLogTag(), &quot;Service was already unbound.&quot; ) ; }</span>
<span class="nc" id="L261">        return this ;</span>
    }

    /**
     * Called by the Android OS when a the service accepts the connection's
     * binding. Notifies all of the connection's listeners that the binding has
     * been completed.
     * @param cn the name of the service component
     * @param binder a binder to the service
     */
    @SuppressWarnings( &quot;unchecked&quot; )     // We are indeed checking the typecast.
    @Override
    public void onServiceConnected( ComponentName cn, IBinder binder )
    {
        InstanceBinder&lt;S&gt; srvb ;
<span class="nc" id="L276">        try { srvb = ((InstanceBinder&lt;S&gt;)(binder)) ; }</span>
<span class="nc" id="L277">        catch( ClassCastException xCast )</span>
        {
<span class="nc" id="L279">            Log.w( this.getLogTag(), (new StringBuilder())</span>
<span class="nc" id="L280">                    .append( &quot;Class [&quot; )</span>
<span class="nc" id="L281">                    .append( m_clsService.getCanonicalName() )</span>
<span class="nc" id="L282">                    .append( &quot;] does not supply a compliant service binding.&quot; )</span>
<span class="nc" id="L283">                    .toString()</span>
                );
<span class="nc" id="L285">            return ;</span>
<span class="nc" id="L286">        }</span>
<span class="nc" id="L287">        m_srvInstance = srvb.getServiceInstance() ;</span>
<span class="nc" id="L288">        m_bBound = true ;</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">        for( Listener&lt;S&gt; l : this.getListeners() )</span>
<span class="nc" id="L290">            l.onServiceConnected(this) ;</span>
<span class="nc" id="L291">    }</span>

    /**
     * Called by the Android OS when a connection's binding to the service must
     * be broken. Notifies all of the connection's listeners that the binding
     * has been broken.
     * @param cn the name of the service component
     */
    @Override
    public void onServiceDisconnected( ComponentName cn )
    {
<span class="nc" id="L302">        m_srvInstance = null ;</span>
<span class="nc" id="L303">        m_bBound = false ;</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">        for( Listener&lt;S&gt; l : this.getListeners() )</span>
<span class="nc" id="L305">            l.onServiceDisconnected(this) ;</span>
<span class="nc" id="L306">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span>Generated by the Android Gradle plugin 3.1.3</div></body></html>