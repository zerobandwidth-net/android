<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SQLiteAssetPortal.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">net.zer0bandwidth.android.lib.database</a> &gt; <span class="el_source">SQLiteAssetPortal.java</span></div><h1>SQLiteAssetPortal.java</h1><pre class="source lang-java linenums">package net.zer0bandwidth.android.lib.database;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper ;
import android.util.Log;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

/**
 * Provides a {@link SQLiteOpenHelper} implementation which manages a read-only
 * database that is loaded from an asset file.
 *
 * &lt;p&gt;See &lt;a href=&quot;https://blog.reigndesign.com/blog/using-your-own-sqlite-database-in-android-applications/&quot;&gt;
 * Using Your Own SQLite Database in Android Applications&lt;/a&gt; for the basis of
 * this implementation.&lt;/p&gt;
 *
 * &lt;h4&gt;Example&lt;/h4&gt;
 *
 * &lt;pre&gt;
 * public class MyDB extends SQLiteAssetPortal
 * {
 *     protected static final String DB_NAME = &quot;mydb&quot; ;
 *
 *     /**
 *      * Rather than using this to represent the version of the database
 *      * schema, use this constant to represent the version of the asset. Thus,
 *      * whenever new content is added to the asset, the app will know to
 *      * overwrite its database with the contents of the new asset. See the
 *      * example of onUpgrade() below.
 *     {@literal *}/
 *     protected static final int DB_VERSION = 2 ;
 *
 *     /** Filename of the asset containing the static database instance. {@literal *}/
 *     protected static final String DB_SOURCE_ASSET = &quot;mydb.v2.db&quot; ;
 *
 *     public MyDB( Context ctx )
 *     { super( ctx, DB_NAME, null, DB_VERSION ) ; }
 *
 *    {@literal @}Override
 *     public abstract String getAssetName()
 *     { return DB_SOURCE_ASSET ; }
 * }
 * &lt;/pre&gt;
 *
 * @since zer0bandwidth-net/android 0.1.4 (#34)
 */
public abstract class SQLiteAssetPortal
extends SQLitePortal
{
<span class="fc" id="L55">	public static final String LOG_TAG =</span>
<span class="fc" id="L56">			SQLiteAssetPortal.class.getSimpleName() ;</span>

/// Inner Classes //////////////////////////////////////////////////////////////

	/**
	 * Allows the {@link SQLiteAssetPortal} to create a persistent connection to
	 * its underlying database on a background thread.
	 * @since zer0bandwidth-net/android 0.1.4 (#34)
	 */
	protected class ConnectionTask
	extends SQLitePortal.ConnectionTask
	implements Runnable
	{
		/**
		 * A reference back to the {@link SQLiteAssetPortal} that needs the
		 * connection.
		 */
<span class="fc" id="L73">		protected SQLiteAssetPortal m_dbh = SQLiteAssetPortal.this ;</span>

		protected ConnectionTask( ConnectionListener l )
<span class="fc" id="L76">		{ m_listener = l ; }</span>

		@Override
		public void run()
		{
<span class="fc" id="L81">			m_dbh.m_db = null ;</span>
<span class="fc" id="L82">			m_dbh.m_bIsConnected = false ;</span>
<span class="fc" id="L83">			try { m_dbh.m_db = m_dbh.getReadableDatabase() ; }</span>
<span class="nc" id="L84">			catch( Exception x )</span>
<span class="pc" id="L85">			{ Log.e( LOG_TAG, &quot;Could not establish initial connection.&quot; ) ; }</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">			if( m_dbh.m_bNeedsCopy ) // set by onCreate() / onUpgrade()</span>
			{ // Close the database connection, copy from asset, and reopen DB.
<span class="fc" id="L88">				m_dbh.close() ;</span>
<span class="fc" id="L89">				m_dbh.copyFromAsset() ;</span>
				try
				{
<span class="fc" id="L92">					m_dbh.m_db = m_dbh.getReadableDatabase() ;</span>
					// Explicitly override the copy flag after this second call,
					// to avoid spurious re-copying of the DB. This must be done
					// because onCreate() can still be called by Android as part
					// of the SQLite DB connection life cycle, and our override
					// would blindly set the copy flag to true.
<span class="fc" id="L98">					m_dbh.m_bNeedsCopy = false ;</span>
				}
<span class="nc" id="L100">				catch( Exception x )</span>
				{
<span class="nc" id="L102">					Log.e( LOG_TAG,</span>
							&quot;Could not connect after copying from asset.&quot; ) ;
<span class="fc" id="L104">				}</span>
			}
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">			m_dbh.m_bIsConnected = ( m_dbh.m_db != null ) ;</span>
<span class="pc bpc" id="L107" title="2 of 4 branches missed.">			if( m_dbh.m_bIsConnected &amp;&amp; m_listener != null )</span>
<span class="nc" id="L108">				m_listener.onDatabaseConnected(m_dbh) ;</span>
<span class="fc" id="L109">		}</span>
	}

/// Instance Members ///////////////////////////////////////////////////////////

	/**
	 * The only method in which the old and new schema versions are exposed is
	 * in {@link #onUpgrade}; thus, that method will set this indicator flag
	 * so that the consumer can then explicitly invoke {@link #copyFromAsset}.
	 */
<span class="fc" id="L119">	protected boolean m_bNeedsCopy = false ;</span>

/// Inherited Constructors (must duplicate here for descendants) ///////////////

	public SQLiteAssetPortal( Context ctx, String sDatabaseName,
							  SQLiteDatabase.CursorFactory cf, int nVersion )
<span class="fc" id="L125">	{ super( ctx, sDatabaseName, cf, nVersion ) ; }</span>

/// android.database.sqlite.SQLiteOpenHelper ///////////////////////////////////

	/**
	 * If the database did not previously exist, then we need to copy it from
	 * the asset.
	 *
	 * &lt;p&gt;Note that, since {@link ConnectionTask} executes
	 * {@link SQLiteOpenHelper#getReadableDatabase()} twice, it is possible that
	 * this method will be called spuriously during the second invocation.
	 * However, since the task immediately resets {@link #m_bNeedsCopy} to
	 * {@code false} after this, this has no negative consequence, other than
	 * the time wasted on the method call.&lt;/p&gt;
	 */
	@Override
	public final void onCreate( SQLiteDatabase db )
	{
<span class="fc" id="L143">		Log.d( LOG_TAG, &quot;onCreate() called; asset may be copied.&quot; ) ;</span>
<span class="fc" id="L144">		m_bNeedsCopy = true ;</span>
<span class="fc" id="L145">	}</span>

	/**
	 * Copy the database asset only if an upgrade is needed.
	 */
	@Override
	public final void onUpgrade( SQLiteDatabase db, int nOld, int nNew )
	{
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">		m_bNeedsCopy = ( nOld &lt; nNew ) ;</span>
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">		if( m_bNeedsCopy )</span>
		{
<span class="fc" id="L156">			Log.d( LOG_TAG, (new StringBuilder())</span>
<span class="fc" id="L157">					.append( &quot;onUpdate(): Asset should be copied; old version [&quot; )</span>
<span class="fc" id="L158">					.append( nOld ).append( &quot;] is less than new version [&quot; )</span>
<span class="fc" id="L159">					.append( nNew ).append( &quot;].&quot; )</span>
<span class="fc" id="L160">					.toString()</span>
				);
		}
<span class="fc" id="L163">	}</span>

/// net.zer0bandwidth.android.lib.database.SQLitePortal ////////////////////////

	/**
	 * Forces the connection to be read-only, and uses the descendant version of
	 * {@link ConnectionTask} to open, and then copy, the database.
	 * @param bReadOnly placebo - always overridden as {@code true} in this
	 *  version of the method
	 * @param l the listener for the &quot;on connected&quot; callback
	 * @return (fluid)
	 */
	@Override
	public synchronized SQLiteAssetPortal openDB( boolean bReadOnly, ConnectionListener l )
	{
<span class="fc" id="L178">		m_bReadOnly = true ;     // Asset-copied databases are always read-only.</span>
<span class="fc" id="L179">		(new SQLiteAssetPortal.ConnectionTask(l)).runInBackground() ;</span>
<span class="fc" id="L180">		return this ;</span>
	}

/// Database from Assets ///////////////////////////////////////////////////////

	/**
	 * Descendant classes must implement this method to provide the name of the
	 * asset from which the database will be replicated.
	 * @return the name of the asset which will be copied as the app's database
	 */
	public abstract String getAssetName() ;

	/**
	 * If indicated by the flag set during connection, this method overwrites
	 * the portal's database with the contents of a static asset packaged in the
	 * APK.
	 * @return {@code true} if the asset was successfully copied; {@code false}
	 *  otherwise
	 */
	protected boolean copyFromAsset()
	{
<span class="fc" id="L201">		final String sAssetFileName = this.getAssetName() ;</span>
<span class="fc" id="L202">		boolean bSuccess = true ;</span>
<span class="fc" id="L203">		InputStream in = null ;</span>
<span class="fc" id="L204">		OutputStream out = null ;</span>
<span class="fc" id="L205">		String sDatabaseName = this.getDatabaseName() ;</span>
		try
		{
<span class="fc" id="L208">			String sDatabaseFile = this.getPathToDatabaseFile() ;</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">			if( this.databaseExists() )</span>
			{
<span class="fc" id="L211">				File fOld = new File( sDatabaseFile ) ;</span>
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">				if( fOld.delete() )</span>
<span class="fc" id="L213">					Log.i( LOG_TAG, &quot;Deleted previous database file!&quot; ) ;</span>
			}
<span class="fc" id="L215">			in = m_ctx.getAssets().open( sAssetFileName ) ;</span>
<span class="fc" id="L216">			out = new FileOutputStream( sDatabaseFile ) ;</span>
<span class="fc" id="L217">			byte[] ayBuffer = new byte[1024] ;</span>
			int nLength ;
<span class="fc" id="L219">			Log.d( LOG_TAG, (new StringBuilder())</span>
<span class="fc" id="L220">					.append( &quot;Copying database from asset [&quot; )</span>
<span class="fc" id="L221">					.append( sAssetFileName )</span>
<span class="fc" id="L222">					.append( &quot;] to database [&quot; )</span>
<span class="fc" id="L223">					.append( sDatabaseName )</span>
<span class="fc" id="L224">					.append( &quot;]...&quot; )</span>
<span class="fc" id="L225">					.toString()</span>
				);
<span class="fc bfc" id="L227" title="All 2 branches covered.">			while( ( nLength = in.read(ayBuffer) ) &gt; 0 )</span>
<span class="fc" id="L228">				out.write( ayBuffer, 0, nLength ) ;</span>
		}
<span class="nc" id="L230">		catch( IOException iox )</span>
		{
<span class="nc" id="L232">			Log.e( LOG_TAG, (new StringBuilder())</span>
<span class="nc" id="L233">					.append( &quot;Could not copy asset [&quot; )</span>
<span class="nc" id="L234">					.append( sAssetFileName )</span>
<span class="nc" id="L235">					.append( &quot;] to database [&quot; )</span>
<span class="nc" id="L236">					.append( sDatabaseName )</span>
<span class="nc" id="L237">					.append( &quot;]:&quot; )</span>
<span class="nc" id="L238">					.toString()</span>
				, iox );
<span class="nc" id="L240">			bSuccess = false ;</span>
		}
		finally
		{ // Ensure the input/output streams are closed.
<span class="pc bpc" id="L244" title="5 of 6 branches missed.">			try { if( in != null ) in.close() ; }</span>
<span class="nc" id="L245">			catch( IOException ioxCloseInput )</span>
			{
<span class="nc" id="L247">				Log.e( LOG_TAG, &quot;Could not close input stream!&quot;,</span>
						ioxCloseInput ) ;
<span class="pc" id="L249">			}</span>
<span class="pc bpc" id="L250" title="5 of 6 branches missed.">			if( out != null )</span>
			{
<span class="pc" id="L252">				try { out.flush() ;  out.close() ; }</span>
<span class="nc" id="L253">				catch( IOException ioxCloseOutput )</span>
				{
<span class="nc" id="L255">					Log.e( LOG_TAG,</span>
							&quot;Could not close output stream!&quot;,
							ioxCloseOutput
						);
<span class="pc" id="L259">				}</span>
			}
		}
<span class="fc" id="L262">		return bSuccess ;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span>Generated by the Android Gradle plugin 3.1.3</div></body></html>