<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SQLiteHouse.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">net.zerobandwidth.android.lib.database.sqlitehouse</a> &gt; <span class="el_source">SQLiteHouse.java</span></div><h1>SQLiteHouse.java</h1><pre class="source lang-java linenums">package net.zerobandwidth.android.lib.database.sqlitehouse;

import android.annotation.SuppressLint;
import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.text.TextUtils;
import android.util.Log;

import net.zerobandwidth.android.lib.database.SQLitePortal;
import net.zerobandwidth.android.lib.database.querybuilder.DeletionBuilder;
import net.zerobandwidth.android.lib.database.querybuilder.QueryBuilder;
import net.zerobandwidth.android.lib.database.querybuilder.SelectionBuilder;
import net.zerobandwidth.android.lib.database.querybuilder.UpdateBuilder;
import net.zerobandwidth.android.lib.database.sqlitehouse.annotations.SQLiteColumn;
import net.zerobandwidth.android.lib.database.sqlitehouse.annotations.SQLiteDatabaseSpec;
import net.zerobandwidth.android.lib.database.sqlitehouse.annotations.SQLiteTable;
import net.zerobandwidth.android.lib.database.sqlitehouse.exceptions.IntrospectionException;
import net.zerobandwidth.android.lib.database.sqlitehouse.exceptions.SchematicException;
import net.zerobandwidth.android.lib.database.sqlitehouse.refractor.NullRefractor;
import net.zerobandwidth.android.lib.database.sqlitehouse.refractor.Refractor;
import net.zerobandwidth.android.lib.database.sqlitehouse.refractor.RefractorMap;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

/**
 * Uses custom annotations to automatically construct and manage SQLite
 * databases with tables in which each row holds a serialization of a specified
 * Java class.
 *
 * &lt;p&gt;This class is based on {@link SQLitePortal} and provides all of the same
 * methods for accessing the database.&lt;/p&gt;
 *
 * &lt;h2&gt;Usage&lt;/h2&gt;
 *
 * &lt;h3&gt;Defining a Database&lt;/h3&gt;
 *
 * &lt;p&gt;Define your SQLite database by creating an empty descendant of
 * {@code SQLiteHouse}, decorated with an {@link SQLiteDatabaseSpec} annotation
 * which describes the basic parameters of the database itself. In the example
 * below, we create a database to hold information about people, places, and
 * things.&lt;/p&gt;
 *
 * &lt;pre&gt;
 *    {@literal @}SQLiteDatabaseSpec(
 *         database_name = &quot;my_database&quot;,
 *         schema_version = 1,
 *         classes = { Person.class, Place.class, Thing.class }
 *     )
 *     public class MyDatabaseClass
 *     extends SQLiteHouse&amp;lt;MyDatabaseClass&amp;gt;
 *     {}
 * &lt;/pre&gt;
 *
 * &lt;p&gt;Note that the descendant class extends {@code SQLiteHouse} with a generic
 * parameter pointing back to itself. This template parameter is used in
 * {@code SQLiteHouse}'s method definitions to ensure that all methods that are
 * &quot;fluid&quot; (&lt;i&gt;i.e.&lt;/i&gt;, which return the same object) will return instances of
 * that descendant class, rather than being typecast up the hierarchy to
 * {@code SQLiteHouse} itself. This pattern allows for more effective method
 * chaining in case the descendant has custom methods that are also fluid.&lt;/p&gt;
 *
 * &lt;h3&gt;Defining the Database Schema&lt;/h3&gt;
 *
 * &lt;p&gt;In the example above, the {@code classes} element of the annotation names
 * three other classes. These are the data objects that you would use in your
 * app to contain the data elements that are stored in the database. By
 * decorating these classes with annotations, the {@code SQLiteHouse} can
 * recognize those classes as data schema definitions, and use the annotations
 * to construct and manage the database automatically.&lt;/p&gt;
 *
 * &lt;p&gt;To continue the previous example, the {@code Person} class is shown below;
 * {@code Place} and {@code Thing} would be similarly defined.&lt;/p&gt;
 *
 * &lt;pre&gt;
 *    {@literal @}SQLiteTable( &quot;people&quot; )
 *     public class Person implements SQLightable
 *     {
 *        {@literal @}SQLiteColumn( name = &quot;person_id&quot;, index = 0 )
 *        {@literal @}SQLitePrimaryKey
 *         protected String m_sID ;
 *
 *        {@literal @}SQLiteColumn( name = &quot;first_name&quot;, index = 1 )
 *         protected String m_sFirstName ;
 *
 *        {@literal @}SQLiteColumn( name = &quot;last_name&quot;, index = 2 )
 *         protected String m_sLastName ;
 *
 *        {@literal @}SQLiteColumn( name = &quot;birthday&quot;, index = 3 )
 *         protected Calendar m_dBirthdate ;
 *
 *        {@literal @}SQLiteColumn( name = &quot;address&quot;, index = 4 )
 *         protected String m_sAddress ;
 *
 *         /** Schema classes must provide a default constructor. {@literal *}/
 *         public Person() {}
 *
 *         // other constructors, methods, etc. follow
 *     }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;Note that the instance members that hold the data need not have the same
 * name as their database columns, nor are they forced to be {@code public}.
 * This system of annotations is designed such that it interferes as little as
 * possible with the other design decisions that might go into the data classes.
 * As long as the fields that correspond to database table columns are properly
 * decorated, they will be discovered and used in the database. Note also that
 * this allows the data object to have any other member fields it wants, which
 * are &lt;i&gt;not&lt;/i&gt; serialized into the database, merely by leaving those members
 * undecorated.&lt;/p&gt;
 *
 * &lt;p&gt;The {@code @SQLitePrimaryKey} annotation explicitly designates a data
 * element which could be used as a primary key for the table. However, the
 * {@code SQLiteHouse} will not actually define the column as such; it will
 * merely be {@code UNIQUE NOT NULL} in the table creation SQL, and a standard,
 * magic {@code _id} column will be used as the actual primary key. This is done
 * because of SQLite's inherent preference for auto-incremented integer keys.
 * However, the {@code SQLiteHouse} will behave as if this function is the
 * actual primary key, allowing consumers to search tables by this field rather
 * than the magic numeric ID.&lt;/p&gt;
 *
 * &lt;p&gt;For notes on the predictability of column order in the table definition,
 * see the {@link ColumnIndexComparator} inner class.&lt;/p&gt;
 *
 * &lt;h3&gt;Constructing a Database Instance&lt;/h3&gt;
 *
 * &lt;p&gt;Use the {@link SQLiteHouse.Factory} class to construct an instance of the
 * database class. The factory will perform all the necessary pre-processing of
 * the {@link SQLiteDatabaseSpec} annotation and feed those parameters into the
 * constructor for the database class instance. The factory is templatized such
 * that your database class does not need to extend it.&lt;/p&gt;
 *
 * &lt;p&gt;The code below continues our example of the {@code MyDatabaseClass} by
 * constructing an instance.&lt;/p&gt;
 *
 * &lt;pre&gt;
 *     // given some Context ctx in which the class will operate
 *     // given some SQLiteHouse.CursorFactory cf for the database helper
 *
 *     MyDatabaseClass dbh = SQLiteHouse.Factory.init().getInstance(
 *             MyDatabaseClass.class, ctx, cf ) ;
 * &lt;/pre&gt;
 *
 * &lt;h3&gt;Custom Processors for Data Classes&lt;/h3&gt;
 *
 * &lt;p&gt;{@code SQLiteHouse} uses implementations of the {@link Refractor}
 * interface to process various data types. The standard set of implementations,
 * generally named &quot;lenses&quot;, are automatically constructed and mapped by the
 * {@link RefractorMap} class. To customize this mapping with your own
 * {@code Refractor} implementations, override the
 * {@link #registerCustomRefractors()} method, which is called by the
 * {@link #SQLiteHouse(Factory)} constructor.&lt;/p&gt;
 *
 * &lt;h3&gt;Connecting to the Database&lt;/h3&gt;
 *
 * &lt;p&gt;Since this class extends {@link SQLitePortal}, which in turn is descended
 * from {@link android.database.sqlite.SQLiteOpenHelper}, it provides the same
 * methods for managing connections to the database. Connections may be
 * established with {@link SQLitePortal#openDB()} and released with
 * {@link SQLitePortal#close()}.&lt;/p&gt;
 *
 * &lt;p&gt;The {@link #onCreate} and {@link #onUpgrade} methods, which ensure that
 * the underlying database is always installed with the current schema, are
 * already implemented in {@code SQLiteHouse}, and use the schematic information
 * discovered by the constructor to handle the database creation and upgrade
 * operations automatically. Descendant classes need not provide their own
 * implementations of these methods, unless they require some exotic
 * post-processing logic after the normal creation/update process has been
 * completed.&lt;/p&gt;
 *
 * &lt;h3&gt;Using the Query Commands&lt;/h3&gt;
 *
 * &lt;p&gt;The base {@code SQLiteHouse} class provides implementations of some basic
 * query operations &amp;mdash; insertion, selection, updates, and deletion. Once
 * all of the schematic data is known to the instance, the grammar of
 * interacting with the database flows relatively simply.&lt;/p&gt;
 *
 * &lt;pre&gt;
 *     MyDatabaseClass dbh = SQLiteHouse.Factory.init().getInstance(
 *             MyDatabaseClass.class, ctx, null ) ;
 *     dbh.openDB() ;
 *     // wait for connection, either by sleeping or catching connection event
 *
 *     Person alice = new Person( UUID.randomUUID().toString(),
 *         &quot;Alice&quot;, &quot;Appleton&quot;, new GregorianCalendar( 1980, 6, 3 ),
 *         &quot;1687 Newton Way, Principia, NY 10705&quot; ) ;
 *     dbh.insert( alice ) ;
 *
 *     Person bob = new Person( UUID.randomUUID().toString(),
 *         &quot;Bob&quot;, &quot;Bullhead&quot;, new GregorianCalendar( 1960, 9, 5 ),
 *         &quot;230 South Bouquet St., Oakland, PA 15213&quot; ) ;
 *     long idBob = dbh.insert( bob ) ;
 *
 *     bob.setAddress( &quot;115 Federal Street, Pittsburgh, PA 15212&quot; ) ;
 *     int nUpdated = dbh.update( bob ) ;                       // nUpdated == 1
 *     Person also_bob = dbh.select( idBob ) ;
 *     String sBobAddress = also_bob.getAddress() ;     // 115 Federal Street...
 *
 *     int nDeleted = dbh.delete( alice ) ;                     // nDeleted == 1
 *     nDeleted = dbh.delete( alice ) ;                         // nDeleted == 0
 *     nDeleted = dbh.delete( bob ) ;                           // nDeleted == 1
 *     nDeleted = dbh.delete( also_bob ) ;                      // nDeleted == 0
 *
 *     dbh.close() ;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;The descendant class may, as with {@link SQLitePortal}, define further
 * custom instance methods to perform more specific reusable queries.&lt;/p&gt;
 *
 * @param &lt;DSC&gt; A descendant class. When creating a descendant class, it should
 *  extend {@code SQLiteHouse} templatized for itself. This will ensure that all
 *  methods inherited from {@code SQLiteHouse} return instances of the
 *  descendant class, rather than the parent class.
 *
 * @since zerobandwidth-net/android 0.1.4 (#26)
 */
public class SQLiteHouse&lt;DSC extends SQLiteHouse&gt;
extends SQLitePortal
{
/// Static Inner Classes ///////////////////////////////////////////////////////

	/**
	 * Creates instances of a {@link SQLiteHouse}. Because we have to have all
	 * our ducks in a row before the {@code SQLiteHouse} calls its ancestor's
	 * constructor, the factory needs to parse the {@link SQLiteDatabaseSpec} in
	 * advance, and feed that information into the constructor as parameters.
	 *
	 * &lt;h3&gt;Usage&lt;/h3&gt;
	 *
	 * &lt;p&gt;Given a {@code Context ctx} and {@code SQLiteDatabase.CursorFactory cf}
	 * (which may be null):&lt;/p&gt;
	 *
	 * &lt;pre&gt;
	 *     MyDatabaseClass dbh = SQLiteHouse.Factory.init().getInstance(
	 *             MyDatabaseClass.class, ctx, cf ) ;
	 * &lt;/pre&gt;
	 *
	 * &lt;p&gt;See {@link SQLiteHouse} for detailed information regarding how this
	 * fits into the overall lifecycle of the object instance.&lt;/p&gt;
	 *
	 * @since zerobandwidth-net/android 0.1.4 (#26)
	 */
<span class="fc" id="L249">	public static class Factory</span>
	{
		/**
		 * Simply an alias for the default constructor, to allow for a cleaner
		 * grammar when creating a factory instance to obtain a reference to a
		 * database.
		 * @return an instance of the factory
		 */
		public static SQLiteHouse.Factory init()
<span class="fc" id="L258">		{ return new SQLiteHouse.Factory() ; }</span>

		/** The context in which the {@code SQLiteHouse} will operate. */
<span class="fc" id="L261">		protected Context m_ctx = null ;</span>

		/**
		 * The name of the database to be created. The factory will glean this
		 * from the {@link SQLiteDatabaseSpec} annotation of the class that is
		 * passed into the {@link #getInstance} method.
		 *
		 * The {@link SQLiteHouse#SQLiteHouse(Factory)} constructor retrieves
		 * this value from the factory to pass it to the parent class's
		 * constructor, {@link SQLitePortal#SQLitePortal}.
		 */
<span class="fc" id="L272">		protected String m_sDatabaseName = null ;</span>

		/**
		 * The cursor factory to be used with the {@link SQLiteHouse} instance,
		 * if any. This is passed as an argument to {@link #getInstance}.
		 *
		 * The {@link SQLiteHouse#SQLiteHouse(Factory)} constructor retrieves
		 * this value from the factory to pass it to the parent class's
		 * constructor, {@link SQLitePortal#SQLitePortal}.
		 */
<span class="fc" id="L282">		protected SQLiteDatabase.CursorFactory m_cf = null ;</span>

		/**
		 * The current schema version of the database. The factory will glean
		 * this from the {@link SQLiteDatabaseSpec} annotation of the class that
		 * is passed into the {@link #getInstance} method.
		 *
		 * The {@link SQLiteHouse#SQLiteHouse(Factory)} constructor retrieves
		 * this value from the factory to pass it to the parent class's
		 * constructor, {@link SQLitePortal#SQLitePortal}.
		 */
<span class="fc" id="L293">		protected int m_nSchemaVersion = SCHEMA_NOT_DEFINED ;</span>

		/**
		 * The array of classes which, in aggregate, define the schema for the
		 * database. The factory will glean this list from the
		 * {@link SQLiteDatabaseSpec} annotation of the class that is passed to
		 * the {@link #getInstance} method.
		 *
		 * The {@link SQLiteHouse#SQLiteHouse(Factory)} constructor uses this
		 * list to construct the schema; see
		 * {@link SQLiteHouse#setSchemaClasses(List)}.
		 */
<span class="fc" id="L305">		protected ArrayList&lt;Class&lt;? extends SQLightable&gt;&gt; m_aclsSchema = null ;</span>

		/**
		 * Uses annotations found in a {@link SQLiteHouse} descendant to
		 * construct an instance of the database class.
		 *
		 * Since this method is templatized on the class that is being
		 * instantiated, there is no need for the {@code SQLiteHouse} descendant
		 * to provide its own extension of {@code SQLiteHouse.Factory}; this
		 * method will return an instance of the descendant class.
		 * @param cls the {@code SQLiteHouse} descendant class being created
		 * @param ctx the context in which the object will operate
		 * @param &lt;FDSC&gt; the {@code SQLiteHouse} descendant being created; this
		 *  matches the class sent in the {@code cls} argument.
		 * @return an instance of the {@code SQLiteHouse} descendant,
		 *  initialized with the database attributes found in the class's
		 *  {@link SQLiteDatabaseSpec} annotation
		 * @throws IntrospectionException if something goes wrong while
		 *  processing the descendant class. When invoking the descendant's
		 *  constructor, there are several possible failure states; use
		 *  {@code .getCause()} to determine which one applies.
		 * @since zerobandwidth-net/android 0.1.7 (#50)
		 */
		public &lt;FDSC extends SQLiteHouse&gt; FDSC getInstance(
				Class&lt;FDSC&gt; cls, Context ctx )
		throws IntrospectionException
<span class="fc" id="L331">		{ return this.getInstance( cls, ctx, null ) ; }</span>

		/**
		 * Uses annotations found in a {@link SQLiteHouse} descendant to
		 * construct an instance of the database class.
		 *
		 * Since this method is templatized on the class that is being
		 * instantiated, there is no need for the {@code SQLiteHouse} descendant
		 * to provide its own extension of {@code SQLiteHouse.Factory}; this
		 * method will return an instance of the descendant class.
		 * @param cls the {@code SQLiteHouse} descendant class being created
		 * @param ctx the context in which the object will operate
		 * @param cf a cursor factory as allowed by the
		 *  {@link android.database.sqlite.SQLiteOpenHelper} constructor (may be
		 *  null)
		 * @param &lt;FDSC&gt; the {@code SQLiteHouse} descendant being created; this
		 *  matches the class sent in the {@code cls} argument.
		 * @return an instance of the {@code SQLiteHouse} descendant,
		 *  initialized with the database attributes found in the class's
		 *  {@link SQLiteDatabaseSpec} annotation
		 * @throws IntrospectionException if something goes wrong while
		 *  processing the descendant class. When invoking the descendant's
		 *  constructor, there are several possible failure states; use
		 *  {@code .getCause()} to determine which one applies.
		 */
		@SuppressWarnings( &quot;unchecked&quot; ) // Constructor is invoked from class.
		public &lt;FDSC extends SQLiteHouse&gt; FDSC getInstance( Class&lt;FDSC&gt; cls,
				Context ctx, SQLiteDatabase.CursorFactory cf )
		throws IntrospectionException
		{
<span class="fc" id="L361">			this.m_ctx = ctx ;</span>
<span class="fc" id="L362">			this.m_cf = cf ;</span>

			try
			{
<span class="fc" id="L366">				SQLiteDatabaseSpec spec =</span>
<span class="fc" id="L367">						cls.getAnnotation( SQLiteDatabaseSpec.class ) ;</span>
<span class="fc" id="L368">				m_sDatabaseName = spec.database_name() ;</span>
<span class="fc" id="L369">				m_nSchemaVersion = spec.schema_version() ;</span>
<span class="fc" id="L370">				this.m_aclsSchema = new ArrayList&lt;&gt;() ;</span>
<span class="fc" id="L371">				this.m_aclsSchema.addAll( Arrays.asList( spec.classes() ) ) ;</span>
			}
<span class="fc" id="L373">			catch( NullPointerException x )</span>
			{
<span class="fc" id="L375">				throw new IntrospectionException(</span>
						&quot;Could not initialize the database instance.&quot; ) ;
<span class="fc" id="L377">			}</span>

			try
			{
<span class="fc" id="L381">				Constructor ctor = cls.getDeclaredConstructor(</span>
						SQLiteHouse.Factory.class ) ;
<span class="fc" id="L383">				ctor.setAccessible( true ) ;</span>
<span class="fc" id="L384">				return ((FDSC)( ctor.newInstance( this ) )) ;</span>
			}
<span class="nc" id="L386">			catch( Exception x )</span>
			{
				// Might catch any of:
				// IllegalAccessException, InstantiationException,
				// InvocationTargetException, NoSuchMethodException
<span class="nc" id="L391">				throw new IntrospectionException(</span>
						&quot;Could not find appropriate constructor in descendant.&quot;,
						x ) ;
			}
		}
	}

	/**
	 * Used by {@link SQLiteHouse} to sort the indices and/or names of columns
	 * within a table specification.
	 * @since zerobandwidth-net/android 0.1.4 (#26)
	 * @see SQLightable.Reflection#initFieldMap()
	 */
<span class="fc" id="L404">	public static class ColumnIndexComparator</span>
	implements Comparator&lt;Field&gt;
	{
		/**
		 * The algorithm in this method prefers to sort a column with an
		 * explicit index definition before any column with no index definition.
		 * For any pair of columns that have the same defined index, or where
		 * neither column has a defined index, the algorithm will sort columns
		 * alphabetically by name instead. The only way to have this method
		 * return {@code 0} (equal) would be to have two columns with the same
		 * name, which is a violation of SQL table requirements anyway.
		 * @param fldFirst the first column to be compared
		 * @param fldSecond the second column to be compared
		 * @return {@code -1} if the first column should be before the second;
		 *  {@code 1} if the first column should be after the second; {@code 0}
		 *  if no sort criteria can be resolved.
		 */
		@Override
		public int compare( Field fldFirst, Field fldSecond )
		{
<span class="fc" id="L424">			SQLiteColumn antFirst =</span>
<span class="fc" id="L425">					fldFirst.getAnnotation( SQLiteColumn.class ) ;</span>
<span class="fc" id="L426">			SQLiteColumn antSecond =</span>
<span class="fc" id="L427">					fldSecond.getAnnotation( SQLiteColumn.class ) ;</span>

			// Try comparing the &quot;index&quot; attribute first.
<span class="fc bfc" id="L430" title="All 2 branches covered.">			if( antFirst.index() == SQLiteColumn.NO_INDEX_DEFINED )</span>
			{
<span class="fc bfc" id="L432" title="All 2 branches covered.">				if( antSecond.index() != SQLiteColumn.NO_INDEX_DEFINED )</span>
				{ // Always sort cols without indices after cols with indices.
<span class="fc" id="L434">					return 1 ;</span>
				}
			}
<span class="fc bfc" id="L437" title="All 2 branches covered.">			else if( antSecond.index() == SQLiteColumn.NO_INDEX_DEFINED )</span>
			{ // Always sort cols without indices after cols with indices.
<span class="fc" id="L439">				return -1 ;</span>
			}
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">			else if( antFirst.index() &lt; antSecond.index() )</span>
<span class="nc" id="L442">				return -1 ;</span>
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">			else if( antFirst.index() &gt; antSecond.index() )</span>
<span class="fc" id="L444">				return 1 ;</span>

			// If &quot;index&quot; is equal, the sort alphabetically.
<span class="fc" id="L447">			String sFirst = antFirst.name() ;</span>
<span class="fc" id="L448">			String sSecond = antSecond.name() ;</span>

<span class="fc" id="L450">			int nCharIndex = 0 ;</span>
<span class="pc bpc" id="L451" title="2 of 4 branches missed.">			while( nCharIndex &lt; sFirst.length() &amp;&amp; nCharIndex &lt; sSecond.length() )</span>
			{
<span class="fc bfc" id="L453" title="All 2 branches covered.">				if( sFirst.charAt(nCharIndex) &lt; sSecond.charAt(nCharIndex) )</span>
<span class="fc" id="L454">					return -1 ;</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">				if( sFirst.charAt(nCharIndex) &gt; sSecond.charAt(nCharIndex) )</span>
<span class="fc" id="L456">					return 1 ;</span>
<span class="fc" id="L457">				++nCharIndex ;</span>
			}

<span class="nc bnc" id="L460" title="All 2 branches missed.">			if( sFirst.length() &lt; sSecond.length() )</span>
<span class="nc" id="L461">				return -1 ;</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">			if( sFirst.length() &gt; sSecond.length() )</span>
<span class="nc" id="L463">				return 1 ;</span>

<span class="nc" id="L465">			return 0 ;</span>
		}
	}

	/**
	 * A short-lived, open data structure which provides context for various
	 * operations within the class. Because so many of the values fetched here
	 * must be reused multiple times within the body of certain larger
	 * functions, or must be passed &lt;i&gt;between&lt;/i&gt; functions, it is useful to
	 * have all of these fields gathered in a single contextual container.
	 * Since 0.1.7 (#50), this class is not particularly different from
	 * {@link SQLightable.Reflection}, but is still not deprecated&amp;hellip; yet.
	 * @since zerobandwidth-net/android 0.1.4 (#26)
	 */
	public static class QueryContext&lt;DBH extends SQLiteHouse&gt;
	{
		/** A persistent reference back to a database portal. */
<span class="fc" id="L482">		public DBH house = null ;</span>
		/** The schematic class providing this context. */
<span class="fc" id="L484">		public Class&lt;? extends SQLightable&gt; clsTable = null ;</span>
		/** The schematic class's table-defining annotation. */
<span class="fc" id="L486">		public SQLiteTable antTable = null ;</span>
		/** The name of the table. */
<span class="fc" id="L488">		public String sTableName = null ;</span>
		/** The field of the schematic class in this context, if any. */
<span class="fc" id="L490">		public Field fldColumn = null ;</span>
		/** The context field's column-defining annotation. */
<span class="fc" id="L492">		public SQLiteColumn antColumn = null ;</span>
		/** The name of the column. */
<span class="fc" id="L494">		public String sColumnName = null ;</span>
		/** Indicates whether the column is annotated as a key. */
<span class="fc" id="L496">		public boolean bColumnIsKey = false ;</span>
		/** The refractor appropriate for this column type. */
<span class="fc" id="L498">		public Refractor lens = null ;</span>
		/** The value of this column in some instance, if set. */
<span class="fc" id="L500">		public String sColumnSQLValue = null ;</span>

		/**
		 * Constructs the instance and binds it back to a {@link SQLiteHouse}.
		 * @param dbh the helper instance
		 * @see SQLiteHouse#getQueryContext()
		 */
		public QueryContext( DBH dbh )
<span class="fc" id="L508">		{ this.house = dbh ; }</span>

		/**
		 * Loads contextual information pertaining to the table defined by the
		 * specified schematic class. This operation clears all
		 * previously-loaded table data, and any data that might have been
		 * loaded for a column of that table.
		 * @param cls the schematic class
		 * @param &lt;SC&gt; the schematic class
		 * @return (fluid)
		 * @throws SchematicException if the class isn't part of the schema
		 */
		public &lt;SC extends SQLightable&gt; QueryContext&lt;DBH&gt; loadTableDef( Class&lt;SC&gt; cls )
		throws SchematicException
		{
<span class="fc" id="L523">			this.clsTable = cls ;</span>
			//noinspection unchecked - guaranteed logically
<span class="fc" id="L525">			SQLightable.Reflection&lt;SC&gt; tbl = this.house.getReflection(cls) ;</span>
<span class="fc" id="L526">			this.antTable = tbl.getTableAttrs() ;</span>
<span class="fc" id="L527">			this.sTableName = tbl.getTableName() ;</span>
<span class="fc" id="L528">			this.clearColumnDef() ;</span>
<span class="fc" id="L529">			return this ;</span>
		}

		/**
		 * Loads contextual information pertaining to a column of the table
		 * already set by {@link #loadTableDef}. This operation will clear the
		 * value of any previously-analyzed column.
		 * @param fld the field to be set for context
		 * @return (fluid)
		 */
		public QueryContext&lt;DBH&gt; loadColumnDef( Field fld )
		{
<span class="fc bfc" id="L541" title="All 2 branches covered.">			if( fld == null )</span>
<span class="fc" id="L542">				return this.clearColumnDef() ;</span>

<span class="fc" id="L544">			this.fldColumn = fld ;</span>
<span class="fc" id="L545">			SQLightable.Reflection.Column col = this.house</span>
<span class="fc" id="L546">					.m_mapReflections.get(this.clsTable).getColumnDef(fld) ;</span>
<span class="fc" id="L547">			this.antColumn = col.getColAttrs() ;</span>
<span class="fc" id="L548">			this.sColumnName = this.antColumn.name() ;</span>
<span class="fc" id="L549">			this.bColumnIsKey = col.isKey() ;</span>
<span class="fc" id="L550">			this.lens = col.getRefractor() ;</span>
<span class="fc" id="L551">			this.sColumnSQLValue = null ;</span>

<span class="fc" id="L553">			return this ;</span>
		}

		/**
		 * Loads contextual information pertaining to a column of the table set
		 * by {@link #loadTableDef}, by searching for that column by its name.
		 * This operation will clear the value of any previously-analyzed
		 * column.
		 * @param sSoughtName the name of the column to be set for context
		 * @return (fluid)
		 */
		public QueryContext&lt;DBH&gt; loadColumnDef( String sSoughtName )
		{
<span class="fc bfc" id="L566" title="All 2 branches covered.">			if( this.clsTable == null )</span>
<span class="fc" id="L567">				throw new IllegalStateException( &quot;No table loaded.&quot; ) ;</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">			if( TextUtils.isEmpty(sSoughtName) )</span>
<span class="fc" id="L569">				return this.clearColumnDef() ;</span>
<span class="fc" id="L570">			SQLightable.Reflection tbl =</span>
<span class="fc" id="L571">					this.house.getReflection( this.clsTable ) ;</span>
<span class="fc" id="L572">			SQLightable.Reflection.Column col = tbl.getColumnDef( sSoughtName );</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">			if( col != null ) return this.loadColumnDef( col.getField() ) ;</span>
<span class="fc" id="L574">			Log.w( LOG_TAG, (new StringBuilder())</span>
<span class="fc" id="L575">					.append( &quot;No column found with name [&quot; )</span>
<span class="fc" id="L576">					.append( sSoughtName )</span>
<span class="fc" id="L577">					.append( &quot;] in table [&quot; )</span>
<span class="fc" id="L578">					.append( this.sTableName )</span>
<span class="fc" id="L579">					.append( &quot;] defined by class [&quot; )</span>
<span class="fc" id="L580">					.append( this.clsTable.getCanonicalName() )</span>
<span class="fc" id="L581">					.append( &quot;]; CLEARING loaded column data.&quot; )</span>
<span class="fc" id="L582">					.toString()</span>
				);
<span class="fc" id="L584">			return this.clearColumnDef() ;</span>
		}

		/**
		 * Clears any and all contextual data pertaining to a table column.
		 * @return (fluid)
		 */
		protected QueryContext&lt;DBH&gt; clearColumnDef()
		{
<span class="fc" id="L593">			this.fldColumn = null ;</span>
<span class="fc" id="L594">			this.antColumn = null ;</span>
<span class="fc" id="L595">			this.sColumnName = null ;</span>
<span class="fc" id="L596">			this.bColumnIsKey = false ;</span>
<span class="fc" id="L597">			this.lens = null ;</span>
<span class="fc" id="L598">			this.sColumnSQLValue = null ;</span>
<span class="fc" id="L599">			return this ;</span>
		}

		/**
		 * If the context is bound to a specific column, then this method will
		 * try to discover the value of the field corresponding to that column
		 * in the specified object instance.
		 * @param o the schematic object that contains the column field
		 * @param &lt;SC&gt; the schematic class
		 * @return (fluid)
		 * @throws IllegalStateException if inadequate context has been loaded
		 * @throws NullPointerException if the schematic object is null
		 * @throws SchematicException if something goes wrong while setting the
		 *  value
		 */
		public &lt;SC extends SQLightable&gt; QueryContext&lt;DBH&gt; loadColumnValue( SC o )
		throws IllegalStateException, NullPointerException, SchematicException
		{
<span class="fc" id="L617">			this.sColumnSQLValue = null ;</span>

<span class="fc bfc" id="L619" title="All 2 branches covered.">			if( o == null )</span>
			{
<span class="fc" id="L621">				throw new NullPointerException(</span>
						&quot;Cannot examine null instance.&quot; ) ;
			}

<span class="fc bfc" id="L625" title="All 2 branches covered.">			if( this.fldColumn == null )</span>
			{
<span class="fc" id="L627">				throw new IllegalStateException(</span>
					&quot;Cannot discover value if no column has been chosen.&quot; ) ;
			}

<span class="fc bfc" id="L631" title="All 2 branches covered.">			if( this.lens == null )</span>
<span class="fc" id="L632">			{ throw SchematicException.noLensForField( this.fldColumn, null ); }</span>

			try
			{
				//noinspection unchecked
<span class="fc" id="L637">				this.sColumnSQLValue = this.lens.toSQLiteString(</span>
<span class="fc" id="L638">						this.lens.getValueFrom( o, this.fldColumn ) ) ;</span>
			}
<span class="nc" id="L640">			catch( IllegalAccessException xAccess )</span>
			{
<span class="nc" id="L642">				throw SchematicException.fieldWasInaccessible(</span>
<span class="nc" id="L643">						this.clsTable.getSimpleName(),</span>
<span class="nc" id="L644">						this.fldColumn.getName(),</span>
						xAccess
					);
<span class="fc" id="L647">			}</span>

<span class="fc" id="L649">			return this ;</span>
		}
	}

/// Static Methods /////////////////////////////////////////////////////////////

	/**
	 * Standardized way to choose the name of a SQLite table based on the class
	 * definition and its annotations, if any.
	 *
	 * @param clsTable the class which defines the SQLite table
	 * @param antTableArg the annotation which relates the class to the schema,
	 *  if any; if {@code null} is passed, this method will still try to
	 *  discover one for itself
	 * @param &lt;SC&gt; the schematic class
	 * @return either the name specified in the annotation, or a lower-cased
	 *  transformation of the class name itself if the annotation is not
	 *  provided
	 * @deprecated zerobandwidth-net/android 0.1.7 (#50)
	 */
	@SuppressWarnings( &quot;unused&quot; )
	protected static &lt;SC extends SQLightable&gt; String getTableName(
			Class&lt;SC&gt; clsTable, SQLiteTable antTableArg )
	{
<span class="nc bnc" id="L673" title="All 2 branches missed.">		SQLiteTable antTable = ( antTableArg == null ?</span>
<span class="nc" id="L674">			clsTable.getAnnotation( SQLiteTable.class ) : antTableArg ) ;</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">		return ( antTable == null ?</span>
<span class="nc" id="L676">			clsTable.getSimpleName().toLowerCase() : antTable.value() ) ;</span>
	}

/// Static Constants ///////////////////////////////////////////////////////////

	/** The tag used by logging statements in this class. */
<span class="fc" id="L682">	public static final String LOG_TAG = SQLiteHouse.class.getSimpleName() ;</span>

	/**
	 * Magic constant to indicate that the schema version has not yet been
	 * resolved.
	 * @see Factory#m_nSchemaVersion
	 */
	protected static final int SCHEMA_NOT_DEFINED = -1 ;

	/**
	 * This magic column name is used in every table to auto-create a row ID as
	 * preferred by SQLite. Table classes should not define a member with this
	 * name.
	 */
	public static final String MAGIC_ID_COLUMN_NAME = &quot;_id&quot; ;

/// Instance Members ///////////////////////////////////////////////////////////

	/**
	 * A list of classes that, in aggregate, define the schema for the database.
	 * @see #setSchemaClasses(List)
	 */
<span class="fc" id="L704">	protected List&lt;Class&lt;? extends SQLightable&gt;&gt; m_aclsSchema = null ;</span>

	/**
	 * A map of schematic classes to their reflections.
	 * @since zerobandwidth-net/android 0.1.7 (#50)
	 */
<span class="fc" id="L710">	protected SQLightable.ReflectionMap m_mapReflections = null ;</span>

	/**
	 * A persistent instance of a refractor map. Descendant classes may be
	 * registered for certain data classes if desired.
	 */
<span class="fc" id="L716">	protected RefractorMap m_mapRefractor = null ;</span>

/// Constructors and Initializers //////////////////////////////////////////////

	/**
	 * Constructor used by the {@link SQLiteHouse.Factory} to create an instance
	 * of the class. The factory passes itself into this constructor, so that it
	 * can provide values for all of the parameters necessary to invoke the
	 * superclass's constructor.
	 *
	 * &lt;p&gt;Descendant classes &lt;b&gt;must&lt;/b&gt; extend this constructor in order to use
	 * the {@link SQLiteHouse.Factory} to properly process the schematic data in
	 * the various data classes.&lt;/p&gt;
	 *
	 * &lt;pre&gt;
	 *     protected MyDatabaseClass( SQLiteHouse.Factory factory )
	 *     { super(factory) ; }
	 * &lt;/pre&gt;
	 *
	 * @param factory the factory which has resolved information about the
	 *  database to be bound to this class
	 */
	protected SQLiteHouse( SQLiteHouse.Factory factory )
	{
<span class="fc" id="L740">		super( factory.m_ctx, factory.m_sDatabaseName,</span>
				factory.m_cf, factory.m_nSchemaVersion ) ;
<span class="fc" id="L742">		this.setSchemaClasses( factory.m_aclsSchema )</span>
<span class="fc" id="L743">		    .processReflections()</span>
			;
<span class="fc" id="L745">		m_mapRefractor = (new RefractorMap()).init() ;</span>
<span class="fc" id="L746">		this.registerCustomRefractors() ;</span>
<span class="fc" id="L747">	}</span>

	/**
	 * Caches a list of classes that define the database schema.
	 *
	 * Consumed by {@link #SQLiteHouse(Factory)}.
	 *
	 * @param aclsSchema the list of classes
	 * @return (fluid)
	 */
	protected DSC setSchemaClasses( List&lt;Class&lt;? extends SQLightable&gt;&gt; aclsSchema )
	{
<span class="fc bfc" id="L759" title="All 2 branches covered.">		if( this.m_aclsSchema == null )</span>
<span class="fc" id="L760">			this.m_aclsSchema = new ArrayList&lt;&gt;() ;</span>
		else
<span class="fc" id="L762">			this.m_aclsSchema.clear() ;</span>
<span class="fc" id="L763">		this.m_aclsSchema.addAll( aclsSchema ) ;</span>

		//noinspection unchecked
<span class="fc" id="L766">		return (DSC)this ;</span>
	}

	/**
	 * Given that the list of schematic classes has been populated, discover and
	 * cache their characteristics for future reference.
	 *
	 * Consumed by {@link #SQLiteHouse(Factory)}; must follow
	 * {@link #setSchemaClasses}.
	 *
	 * @return (fluid)
	 * @since zerobandwidth-net/android 0.1.7 (#50)
	 */
	protected DSC processReflections()
	{
<span class="fc bfc" id="L781" title="All 2 branches covered.">		if( m_mapReflections == null )</span>
<span class="fc" id="L782">			m_mapReflections = new SQLightable.ReflectionMap() ;</span>
<span class="fc" id="L783">		else m_mapReflections.clear() ;</span>

<span class="fc bfc" id="L785" title="All 2 branches covered.">		for( Class&lt;? extends SQLightable&gt; cls : m_aclsSchema )</span>
		{
<span class="fc" id="L787">			SQLightable.Reflection&lt;? extends SQLightable&gt; tbl =</span>
<span class="fc" id="L788">					SQLightable.Reflection.reflect(cls) ;</span>
<span class="fc" id="L789">			m_mapReflections.put( cls, tbl ) ;</span>
<span class="fc" id="L790">		}</span>

		//noinspection unchecked
<span class="fc" id="L793">		return (DSC)this ;</span>
	}

	/**
	 * Consumed by the constructor, this method registers any custom
	 * {@link Refractor} implementations that should be used by the instance.
	 * The default implementation of this method returns trivially; descendants
	 * of {@code SQLiteHouse} may override this method to add any custom
	 * {@code Refractor} implementations here.
	 * @return (fluid)
	 * @see Refractor
	 * @see RefractorMap
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	protected DSC registerCustomRefractors()
<span class="fc" id="L808">	{ return (DSC)this ; } // trivially</span>

/// net.zerobandwidth.android.lib.database.SQLitePortal ////////////////////////

	/**
	 * Called by Android when the consumer tries to connect to the database.
	 * This method will iterate over the list of table classes and execute the
	 * SQL statement which will create that table.
	 *
	 * &lt;p&gt;This method was designed to be a {@code final} implementation, but is
	 * left extensible for descendant classes, just in case they might need to
	 * perform any custom post-processing.&lt;/p&gt;
	 *
	 * @param db a direct handle to the SQLite database (provided by the Android
	 *  OS)
	 * @throws SchematicException &lt;i&gt;(since 0.1.7 #50)&lt;/i&gt; if something goes
	 *  wrong while processing the schema definition
	 */
	@Override
	public void onCreate( SQLiteDatabase db )
	throws SchematicException
	{
<span class="fc" id="L830">		Log.i( LOG_TAG, &quot;Executing onCreate()&quot; ) ;</span>
<span class="fc bfc" id="L831" title="All 2 branches covered.">		for( Class&lt;? extends SQLightable&gt; clsTable : m_aclsSchema )</span>
		{
<span class="fc" id="L833">			SQLightable.Reflection tbl = this.getReflection(clsTable) ;</span>
<span class="fc" id="L834">			String sSQL = null ;</span>
			try
			{
<span class="fc" id="L837">				sSQL = tbl.getTableCreationSQL() ;</span>
<span class="fc" id="L838">				db.execSQL( sSQL ) ;</span>
			}
<span class="nc" id="L840">			catch( Exception x )</span>
			{
<span class="nc" id="L842">				throw SchematicException</span>
<span class="nc" id="L843">						.tableCreationOrUpdateFailed( tbl, sSQL, x ) ;</span>
<span class="fc" id="L844">			}</span>
<span class="fc" id="L845">		}</span>
<span class="fc" id="L846">	}</span>

	/**
	 * Called by Android when the consumer tries to connect to the database, and
	 * the current schema version in the class is newer than the one that is
	 * currently installed. This method iterates over the list of schema classes
	 * and, if the table's {@code since} version is newer than the old version,
	 * will create the table. Otherwise, it will analyze the table's columns,
	 * and if any column's {@code since} version is newer than the old version,
	 * the method will add the column to the table.
	 *
	 * &lt;p&gt;This method was designed to be a {@code final} implementation, but is
	 * left extensible for descendant classes, just in case they might need to
	 * perform any custom post-processing.&lt;/p&gt;
	 *
	 * @param db a direct handle to the SQLite database (provided by the Android
	 *  OS)
	 * @param nOld the version of the schema that is installed
	 * @param nNew the version of the schema that is defined
	 */
	@Override
	public void onUpgrade( SQLiteDatabase db, int nOld, int nNew )
	{
<span class="fc" id="L869">		Log.i( LOG_TAG, (new StringBuilder())</span>
<span class="fc" id="L870">				.append( &quot;Executing onUpgrade() from old version [&quot; )</span>
<span class="fc" id="L871">				.append( nOld ).append( &quot;] to new version [&quot; )</span>
<span class="fc" id="L872">				.append( nNew ).append( &quot;]...&quot; )</span>
<span class="fc" id="L873">				.toString()</span>
			);
<span class="fc bfc" id="L875" title="All 2 branches covered.">		for( Class&lt;? extends SQLightable&gt; clsTable : m_aclsSchema )</span>
<span class="fc" id="L876">			this.upgradeTable( db, clsTable, nOld ) ;</span>
<span class="fc" id="L877">	}</span>

	/**
	 * Called by {@link #onUpgrade} to upgrade a single SQLite database table
	 * based on the information reflected by a specific schematic class.
	 * @param db a direct handle to the SQLite database (provided to
	 *           {@link #onUpgrade} by the Android OS)
	 * @param clsTable the schematic class that defines the table
	 * @param nOld the version of the schema that is installed
	 * @param &lt;SC&gt; the schematic class
	 * @return (fluid)
	 * @throws SchematicException if the class is not part of the schema
	 * @since zerobandwidth-net/android 0.1.7 (#50)
	 */
	protected &lt;SC extends SQLightable&gt; SQLiteHouse&lt;DSC&gt; upgradeTable(
			SQLiteDatabase db, Class&lt;SC&gt; clsTable, int nOld )
	throws SchematicException
	{
<span class="fc" id="L895">		SQLightable.Reflection&lt;SC&gt; tbl = this.getReflection(clsTable) ;</span>
<span class="fc" id="L896">		int nTableSince = tbl.getFirstSchemaVersion() ;</span>
<span class="fc bfc" id="L897" title="All 2 branches covered.">		if( nTableSince &gt; nOld )</span>
		{ // The whole table is new; create it.
<span class="fc" id="L899">			db.execSQL( tbl.getTableCreationSQL() ) ;</span>
<span class="fc" id="L900">			Log.i( LOG_TAG, (new StringBuilder())</span>
<span class="fc" id="L901">					.append( &quot;Created table [&quot; ).append( tbl.getTableName() )</span>
<span class="fc" id="L902">					.append( &quot;] from class [&quot; )</span>
<span class="fc" id="L903">					.append( clsTable.getCanonicalName() )</span>
<span class="fc" id="L904">					.append( &quot;].&quot; )</span>
<span class="fc" id="L905">					.toString()</span>
				);
		}
		else
		{ // Examine the table's columns, creating new ones where needed.
<span class="fc" id="L910">			SQLightable.Reflection.ColumnMap&lt;SC&gt; mapColumns =</span>
<span class="fc" id="L911">					tbl.getColumnMap() ;</span>
<span class="fc bfc" id="L912" title="All 2 branches covered.">			for( SQLightable.Reflection&lt;SC&gt;.Column col : mapColumns.values() )</span>
			{
<span class="fc" id="L914">				int nColSince = col.getColAttrs().since() ;</span>
<span class="fc bfc" id="L915" title="All 2 branches covered.">				if( nColSince &gt; nOld )</span>
				{
<span class="fc" id="L917">					db.execSQL( tbl.getAddColumnSQL(col) ) ;</span>
<span class="fc" id="L918">					Log.i( LOG_TAG, (new StringBuilder())</span>
<span class="fc" id="L919">							.append( &quot;Added column [&quot; )</span>
<span class="fc" id="L920">							.append( col.getName() )</span>
<span class="fc" id="L921">							.append( &quot;] to table [&quot; )</span>
<span class="fc" id="L922">							.append( tbl.getTableName() )</span>
<span class="fc" id="L923">							.append( &quot;] from class [&quot; )</span>
<span class="fc" id="L924">							.append( clsTable.getCanonicalName() )</span>
<span class="fc" id="L925">							.append( &quot;].&quot; )</span>
<span class="fc" id="L926">							.toString()</span>
						);
				}
<span class="fc" id="L929">			}</span>
		}

<span class="fc" id="L932">		return this ;</span>
	}

/// Query Commands /////////////////////////////////////////////////////////////

	/**
	 * Inserts an object of a known schematic class into the database.
	 *
	 * Since v0.1.5 (#43), the method also tries to write the auto-incremented
	 * row ID back into the object instance, if that class has a field annotated
	 * to contain that column.
	 *
	 * @param o the object to be inserted
	 * @return the row ID of the inserted record
	 */
	public &lt;ROW extends SQLightable&gt; long insert( ROW o )
	throws SchematicException
	{
		//noinspection unchecked
<span class="fc" id="L951">		Class&lt;ROW&gt; cls = ((Class&lt;ROW&gt;)( o.getClass() ));</span>
<span class="fc" id="L952">		SQLightable.Reflection&lt;ROW&gt; tbl = this.getReflection(cls) ;</span>
<span class="fc" id="L953">		SQLightable.Reflection&lt;ROW&gt;.Column col = tbl.getMagicIDColumn() ;</span>
<span class="fc" id="L954">		ContentValues vals = tbl.toContentValues(o) ;</span>
		// Don't allow the passed object to dictate the auto-inc ID.
<span class="fc bfc" id="L956" title="All 2 branches covered.">		if( col != null ) vals.remove( MAGIC_ID_COLUMN_NAME ) ;</span>

<span class="fc" id="L958">		long nID = QueryBuilder</span>
<span class="fc" id="L959">				.insertInto( m_db, tbl.getTableName() )</span>
<span class="fc" id="L960">				.setValues( vals )</span>
<span class="fc" id="L961">				.execute()</span>
				;

<span class="fc bfc" id="L964" title="All 2 branches covered.">		if( col != null )</span>
		{ // Try to write the ID back into the instance.
<span class="fc" id="L966">			try { col.getField().setLong( o, nID ) ; }</span>
<span class="nc" id="L967">			catch( IllegalAccessException xAccess )</span>
<span class="pc" id="L968">			{ Log.w( LOG_TAG, &quot;Couldn't rewrite row ID into object.&quot; ) ; }</span>
		}

<span class="fc" id="L971">		return nID ;</span>
	}

	/**
	 * Updates the values of an object from a known schematic class.
	 * @param o the object to be updated
	 * @return the number of rows updated (generally 1)
	 * @throws SchematicException if the data object's class isn't part of the
	 *  schema, or if the table definition for this class didn't specify its own
	 *  primary key
	 */
	public &lt;ROW extends SQLightable&gt; int update( ROW o )
	throws SchematicException
	{
		//noinspection unchecked
<span class="fc" id="L986">		SQLightable.Reflection&lt;ROW&gt; tbl = ((SQLightable.Reflection&lt;ROW&gt;)</span>
<span class="fc" id="L987">				( this.getReflection( o.getClass() ) )) ;</span>
<span class="fc" id="L988">		SQLightable.Reflection&lt;ROW&gt;.Column col = tbl.getKeyOrMagicIDColumn() ;</span>
<span class="pc bpc" id="L989" title="1 of 2 branches missed.">		if( col == null )</span>
		{
<span class="nc" id="L991">			throw new SchematicException(</span>
					&quot;Can't use update(SQLightable) without a key column.&quot; ) ;
		}
<span class="fc" id="L994">		return QueryBuilder.update( m_db, tbl.getTableName() )</span>
<span class="fc" id="L995">				.setValues( tbl.toContentValues(o) )</span>
<span class="fc" id="L996">				.where( String.format( &quot;%s=%s&quot;,</span>
<span class="fc" id="L997">						col.getName(), col.getSQLColumnValueFrom(o) ) )</span>
<span class="fc" id="L998">				.execute()</span>
				;
	}

	/**
	 * Shorthand to obtain an {@link UpdateBuilder} bound to this database and
	 * targeting the table corresponding to the specified schematic class.
	 * @param cls the class that defines part of the schema
	 * @return an {@code UPDATE} query builder prepared for that table
	 * @throws SchematicException if the class is not part of the schema
	 */
	public &lt;SC extends SQLightable&gt; UpdateBuilder update( Class&lt;SC&gt; cls )
	throws SchematicException
	{
<span class="fc" id="L1012">		return QueryBuilder.update( m_db,</span>
<span class="fc" id="L1013">						this.getReflection(cls).getTableName() ) ;</span>
	}

	/**
	 * Searches the database for a row of the table represented by the supplied
	 * object, such that the primary key value in that object equals the primary
	 * key found in the object. The method does not alter the supplied object;
	 * instead, it returns a new instance with the values found in the database.
	 * @param oCriteria the object whose primary key will be used as the
	 *  criteria for a search
	 * @param &lt;ROW&gt; the specific {@link SQLightable} implementation being sought
	 * @return a new instance of the schematic class, populated with values from
	 *  a row of the database
	 * @throws SchematicException if anything goes wrong along the way
	 */
	public &lt;ROW extends SQLightable&gt; ROW search( ROW oCriteria )
	throws SchematicException
	{
		//noinspection unchecked
<span class="fc" id="L1032">		SQLightable.Reflection&lt;ROW&gt; tbl = ((SQLightable.Reflection&lt;ROW&gt;)</span>
<span class="fc" id="L1033">						( this.getReflection( oCriteria.getClass() ) )) ;</span>
<span class="fc" id="L1034">		SQLightable.Reflection&lt;ROW&gt;.Column col = tbl.getKeyOrMagicIDColumn() ;</span>
<span class="fc bfc" id="L1035" title="All 2 branches covered.">		if( col == null )</span>
		{
<span class="fc" id="L1037">			throw new SchematicException(</span>
					&quot;Can't use search(SQLightable) without a key column.&quot; ) ;
		}
<span class="fc" id="L1040">		Cursor crs = null ;</span>
		try
		{
<span class="fc" id="L1043">			crs = QueryBuilder.selectFrom( m_db, tbl.getTableName() )</span>
<span class="fc" id="L1044">					.where( String.format( &quot;%s=%s&quot;,</span>
<span class="fc" id="L1045">			              col.getName(), col.getSQLColumnValueFrom(oCriteria) ))</span>
<span class="fc" id="L1046">					.execute()</span>
					;
<span class="fc bfc" id="L1048" title="All 2 branches covered.">			if( ! crs.moveToFirst() ) return null ; // No such object found.</span>
<span class="fc" id="L1049">			return tbl.fromCursor(crs) ;</span>
		}
		finally
<span class="pc" id="L1052">		{ closeCursor(crs) ; }</span>
	}

	/**
	 * Searches the database for a row of the table represented by the supplied
	 * schematic class, such that the primary key column value matches the value
	 * supplied in the method call.
	 * @param cls the schematic class being sought
	 * @param sID the unique identifier of the row, which &lt;i&gt;must&lt;/i&gt; be a
	 *            string in this flavor of the method
	 * @param &lt;ROW&gt; the schematic class being sought
	 * @return a new instance of the schematic class, populated with values from
	 *  a row of the database
	 * @throws SchematicException if anything goes wrong along the way
	 * @since zerobandwidth-net/android 0.1.5
	 */
	public &lt;ROW extends SQLightable&gt; ROW search( Class&lt;ROW&gt; cls, String sID )
	throws SchematicException
	{
<span class="fc" id="L1071">		SQLightable.Reflection&lt;ROW&gt; tbl = this.getReflection(cls) ;</span>
<span class="fc" id="L1072">		SQLightable.Reflection&lt;ROW&gt;.Column colKey = tbl.getKeyColumn() ;</span>
<span class="fc bfc" id="L1073" title="All 2 branches covered.">		if( colKey == null )</span>
		{
<span class="fc" id="L1075">			throw new SchematicException(</span>
					&quot;Can't use search(Class,String) without a key column.&quot; ) ;
		}
<span class="fc" id="L1078">		Cursor crs = null ;</span>
		try
		{
<span class="fc" id="L1081">			crs = QueryBuilder.selectFrom( m_db, tbl.getTableName() )</span>
<span class="fc" id="L1082">					.where( String.format( &quot;%s='%s'&quot;,</span>
<span class="fc" id="L1083">			              colKey.getName(), sID ) )</span>
<span class="fc" id="L1084">					.execute()</span>
					;
<span class="fc bfc" id="L1086" title="All 2 branches covered.">			if( ! crs.moveToFirst() ) return null ;     // No such object found.</span>
<span class="fc" id="L1087">			return tbl.fromCursor(crs) ;</span>
		}
		finally
<span class="pc" id="L1090">		{ closeCursor(crs) ; }</span>
	}

	/**
	 * Searches the database for a row of the table represented by the supplied
	 * object, where the specified integer is equal to the row's magic auto-ID.
	 * @param cls the schematic class that will contain the row
	 * @param nID the auto-incremented integer ID of the row
	 * @param &lt;ROW&gt; the schematic class
	 * @return a new instance of the schematic class, containing the row with
	 *  the specified auto-ID
	 * @throws SchematicException if the class is not part of the schema
	 */
	@SuppressLint(&quot;DefaultLocale&quot;)
	public &lt;ROW extends SQLightable&gt; ROW select( Class&lt;ROW&gt; cls, long nID )
	throws SchematicException
	{
<span class="fc" id="L1107">		SQLightable.Reflection&lt;ROW&gt; tbl = this.getReflection(cls) ;</span>
<span class="fc" id="L1108">		Cursor crs = null ;</span>
		try
		{
<span class="fc" id="L1111">			crs = QueryBuilder.selectFrom( m_db, tbl.getTableName() )</span>
<span class="fc" id="L1112">					.where( String.format( &quot;%s=%d&quot;,</span>
<span class="fc" id="L1113">							MAGIC_ID_COLUMN_NAME, nID ) )</span>
<span class="fc" id="L1114">					.execute()</span>
					;
<span class="fc bfc" id="L1116" title="All 2 branches covered.">			if( ! crs.moveToFirst() ) return null ; // No such object found.</span>
<span class="fc" id="L1117">			return tbl.fromCursor(crs) ;</span>
		}
		finally
<span class="pc" id="L1120">		{ closeCursor(crs) ; }</span>
	}

	/**
	 * Shorthand to obtain a {@link SelectionBuilder} bound to this database and
	 * targeting the table corresponding to the specified schematic class.
	 * @param cls the schematic class
	 * @param &lt;SC&gt; the schematic class
	 * @return a {@code SELECT} query builder prepared for that table
	 * @throws SchematicException if the class is not part of the schema
	 */
	public &lt;SC extends SQLightable&gt; SelectionBuilder selectFrom( Class&lt;SC&gt; cls )
	throws SchematicException
	{
<span class="fc" id="L1134">		return QueryBuilder.selectFrom( m_db,</span>
<span class="fc" id="L1135">						this.getReflection(cls).getTableName() ) ;</span>
	}

	/**
	 * Searches the database for a row of the table represented by the supplied
	 * objects, and deletes that row.
	 * @param o the schematic class instance to be deleted if found
	 * @param &lt;ROW&gt; the schematic class
	 * @return the number of rows deleted
	 * @throws SchematicException if the table is not part of the schema, or
	 *  doesn't specify a key column
	 */
	public &lt;ROW extends SQLightable&gt; int delete( ROW o )
	throws SchematicException
	{
		//noinspection unchecked
<span class="fc" id="L1151">		SQLightable.Reflection&lt;ROW&gt; tbl = ((SQLightable.Reflection&lt;ROW&gt;)</span>
<span class="fc" id="L1152">				( this.getReflection( o.getClass() ) )) ;</span>
<span class="fc" id="L1153">		SQLightable.Reflection&lt;ROW&gt;.Column col = tbl.getKeyOrMagicIDColumn() ;</span>
<span class="fc bfc" id="L1154" title="All 2 branches covered.">		if( col == null )</span>
		{
<span class="fc" id="L1156">			throw new SchematicException(</span>
					&quot;Can't use delete(SQLightable) without a key column.&quot; ) ;
		}
<span class="fc" id="L1159">		return QueryBuilder.deleteFrom( m_db, tbl.getTableName() )</span>
<span class="fc" id="L1160">			.where( String.format( &quot;%s=%s&quot;,</span>
<span class="fc" id="L1161">				col.getName(), col.getSQLColumnValueFrom(o) ) )</span>
<span class="fc" id="L1162">			.execute()</span>
			;
	}

	/**
	 * Shorthand to obtain a {@link DeletionBuilder} bound to this database and
	 * targeting the table corresponding to the specified schematic class.
	 * @param cls the class that defines part of the schema
	 * @return a {@code DELETE} query builder prepared for that table
	 * @throws SchematicException if the class is not part of the schema
	 */
	public &lt;SC extends SQLightable&gt; DeletionBuilder deleteFrom( Class&lt;SC&gt; cls )
	throws SchematicException
	{
<span class="fc" id="L1176">		return QueryBuilder.deleteFrom( m_db,</span>
<span class="fc" id="L1177">				this.getReflection(cls).getTableName() ) ;</span>
	}

/// Other Instance Methods /////////////////////////////////////////////////////

	/**
	 * Accesses the reflection of a class that is marshalled by this instance.
	 * If the class was not included in the list of classes that is part of the
	 * instance's schema, then the method returns {@code null}, rather than
	 * invoking {@link SQLightable.Reflection#reflect(Class)}.
	 * @param cls the schematic class to be described
	 * @param &lt;SC&gt; the schematic class to be described
	 * @return the reflection of that class as stored in this instance
	 * @since zerobandwidth-net/android 0.1.7 (#50)
	 */
	public &lt;SC extends SQLightable&gt; SQLightable.Reflection&lt;SC&gt; describe( Class&lt;SC&gt; cls )
<span class="fc" id="L1193">	{ return m_mapReflections.get(cls) ; }</span>

	/**
	 * Similar to {@link #describe}, but will throw a {@link SchematicException}
	 * if the specified class is not found. This is more useful internally than
	 * as a generaly utility, hence the {@code protected} access control.
	 * @param cls the schematic class to be described
	 * @param &lt;SC&gt; the schematic class to be described
	 * @return the reflection of that class as stored in this instance
	 * @throws SchematicException if the class is not found in this instance
	 * @since zerobandwidth-net/android 0.1.7 (#50)
	 */
	protected &lt;SC extends SQLightable&gt; SQLightable.Reflection&lt;SC&gt; getReflection( Class&lt;SC&gt; cls )
	throws SchematicException
	{
<span class="fc" id="L1208">		SQLightable.Reflection&lt;SC&gt; tbl = m_mapReflections.get(cls) ;</span>
<span class="fc bfc" id="L1209" title="All 2 branches covered.">		if( tbl == null )</span>
<span class="fc" id="L1210">			throw SchematicException.classNotInSchema( cls, m_aclsSchema ) ;</span>
<span class="fc" id="L1211">		return tbl ;</span>
	}

	/**
	 * Reads a row of data from a cursor, and marshals it into a schematic class
	 * instance corresponding to the table from which the row was fetched.
	 *
	 * &lt;p&gt;Consumed by {@link #search} and {@link #select}, and may also be
	 * consumed externally by any class that receives a cursor over results from
	 * a {@code SELECT} query.&lt;/p&gt;
	 *
	 * @param qctx the context of the selection query
	 * @param crs the cursor currently pointing to a data row
	 * @param &lt;SC&gt; the schematic class
	 * @return an instance of the class, containing the cursor's current row
	 * @throws SchematicException if the data class instance cannot be
	 *  constructed for some reason
	 * @deprecated zerobandwidth-net/android 0.1.7 (#50) - use
	 *  {@link #fromCursor(Cursor,Class)}
	 */
	public &lt;SC extends SQLightable&gt; SC fromCursor(
			QueryContext&lt;DSC&gt; qctx, Cursor crs )
	throws SchematicException
	{
		//noinspection unchecked - guaranteed
<span class="nc" id="L1236">		SQLightable.Reflection&lt;SC&gt; tbl = ((SQLightable.Reflection&lt;SC&gt;)</span>
<span class="nc" id="L1237">					( this.getReflection(qctx.clsTable) )) ;</span>
<span class="nc" id="L1238">		return tbl.fromCursor( crs ) ;</span>
	}

	/**
	 * Alias for {@link #fromCursor(Cursor,Class)} to support apps that consume
	 * a version of the library between 0.1.5 and 0.1.7.
	 * @param qctx the context of the selection query; ignored because we don't
	 *             need it anymore
	 * @param crs the cursor currently pointing at a data row
	 * @param cls the schematic class
	 * @param &lt;SC&gt; the schematic class
	 * @return an instance of the class, containing the cursor's current row
	 * @throws SchematicException if the data class instance cannot be
	 *  constructed for some reason
	 * @since zerobandwidth-net/android 0.1.5 (#43)
	 * @deprecated zerobandwidth-net/android 0.1.7 (#50) -
	 *  use {@link #fromCursor(Cursor,Class)}
	 */
	@SuppressWarnings( &quot;UnusedParameters&quot; ) // see note above
	public &lt;SC extends SQLightable&gt; SC fromCursor(
			QueryContext&lt;DSC&gt; qctx, Cursor crs, Class&lt;SC&gt; cls )
	throws SchematicException
<span class="nc" id="L1260">	{ return this.fromCursor(crs,cls) ; }</span>

	/**
	 * Reads a row of data from a cursor, and marshals it into a schematic class
	 * instance corresponding to the table from which the row was fetched.
	 * @param crs the cursor from which data will be marshalled
	 * @param cls the schematic class to which data will be marshalled
	 * @param &lt;SC&gt; the schematic class to which data will be marshalled
	 * @return an instance of the class, containing the cursor's current row
	 * @throws SchematicException if the class is not part of the schema
	 */
	public &lt;SC extends SQLightable&gt; SC fromCursor( Cursor crs, Class&lt;SC&gt; cls )
	throws SchematicException
<span class="fc" id="L1273">	{ return this.getReflection(cls).fromCursor(crs) ; }</span>

	/**
	 * Given a result set loaded into a {@link Cursor}, iterate over that cursor
	 * to produce a list of schematic class instances containing the rows in the
	 * result set.
	 * @param qctx the context of the selection query
	 * @param crs the cursor containing a result set
	 * @param cls the schematic class which could contain each row
	 * @param &lt;SC&gt; the schematic class which could contain each row
	 * @return a list of schematic class instances, containing the rows of the
	 *  result set
	 * @throws SchematicException if any instance cannot be instantiated
	 * @since zerobandwidth-net/android 0.1.5 (#43)
	 * @deprecated zerobandwidth-net/android 0.1.7 (#50) - use
	 *  {@link #processResultSet(Class, Cursor)}
	 */
	@SuppressWarnings( &quot;UnusedParameters&quot; )
	public &lt;SC extends SQLightable&gt; List&lt;SC&gt; processResultSet(
			QueryContext&lt;DSC&gt; qctx, Cursor crs, Class&lt;SC&gt; cls )
	throws SchematicException
<span class="fc" id="L1294">	{ return this.processResultSet( cls, crs ) ; }</span>

	/**
	 * Given a result set loaded into a {@link Cursor}, iterate over that cursor
	 * to produce a list of schematic class instances containing the rows in the
	 * result set.
	 * @param cls the schematic class which could contain each row
	 * @param crs the cursor containing the result set
	 * @param &lt;SC&gt; the schematic class which could contain each row
	 * @return a list of schematic class instances, containing the rows of the
	 *  result set
	 * @throws SchematicException if any instance cannot be instantiated
	 * @since zerobandwidth-net/android 0.1.5 (#43)
	 */
	public &lt;SC extends SQLightable&gt; List&lt;SC&gt; processResultSet(
			Class&lt;SC&gt; cls, Cursor crs )
	throws SchematicException
	{
<span class="fc" id="L1312">		List&lt;SC&gt; aResults = new ArrayList&lt;&gt;() ;</span>
<span class="fc bfc" id="L1313" title="All 2 branches covered.">		if( crs.moveToFirst() )</span>
		{ // Process each element in turn, marshalling it into the list.
<span class="fc" id="L1315">			do aResults.add( this.getReflection(cls).fromCursor(crs) ) ;</span>
<span class="fc bfc" id="L1316" title="All 2 branches covered.">			while( crs.moveToNext() ) ;</span>
		}
<span class="fc" id="L1318">		return aResults ;</span>
	}

	/**
	 * Creates an empty query context bound to this database helper.
	 * @return a context object
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public QueryContext&lt;DSC&gt; getQueryContext()
<span class="fc" id="L1327">	{ return new QueryContext&lt;&gt;( (DSC)this ) ; }</span>

	/**
	 * Creates a query context bound to this database helper, and pre-loads the
	 * information for a specified table.
	 * @param clsTable the schematic table to be pre-loaded
	 * @return a context object
	 */
	public QueryContext&lt;DSC&gt; getQueryContext( Class&lt;? extends SQLightable&gt; clsTable )
<span class="fc" id="L1336">	{ return this.getQueryContext().loadTableDef(clsTable) ; }</span>

	/**
	 * Accesses the cache of schematic classes for the database.
	 * @return the list of schematic classes loaded into this instance
	 * @since zerobandwidth-net/android 0.1.7 (#50)
	 */
	public List&lt;Class&lt;? extends SQLightable&gt;&gt; getSchemaClasses()
<span class="fc" id="L1344">	{ return m_aclsSchema ; }</span>

	/**
	 * Discovers the type of refractor needed to marshal the specified field.
	 *
	 * Since 0.1.5 (#41), the method will try to discover whether there is a
	 * usable custom implementation specified in the column annotation, and
	 * return that if such a specification exists.
	 *
	 * @param fld a field in a schematic class
	 * @return the refractor which would marshal that class
	 * @throws IntrospectionException if no refractor can be discovered
	 */
	public Refractor&lt;?&gt; getRefractorForField( Field fld )
	throws IntrospectionException
	{
<span class="fc" id="L1360">		SQLiteColumn antCol = fld.getAnnotation( SQLiteColumn.class ) ;</span>
<span class="fc" id="L1361">		Class&lt;? extends Refractor&gt; clsLens = antCol.refractor() ;</span>
<span class="fc bfc" id="L1362" title="All 2 branches covered.">		if( clsLens != NullRefractor.class ) try</span>
		{ // The field explicitly defines a custom refractor. Use it.
<span class="fc" id="L1364">			return clsLens.newInstance() ;</span>
		}
<span class="fc" id="L1366">		catch( Exception x )</span>
		{
<span class="fc" id="L1368">			Log.w( LOG_TAG, (new StringBuilder())</span>
<span class="fc" id="L1369">					.append( &quot;Cannot instantiate custom refractor class [&quot; )</span>
<span class="fc" id="L1370">					.append( clsLens.getCanonicalName() )</span>
<span class="fc" id="L1371">					.append( &quot;].&quot; )</span>
<span class="fc" id="L1372">					.toString(),</span>
				x ) ;
		}

<span class="fc" id="L1376">		try { return m_mapRefractor.get( fld.getType() ).newInstance() ; }</span>
<span class="fc" id="L1377">		catch( Exception x )</span>
		{
<span class="fc" id="L1379">			throw new IntrospectionException( (new StringBuilder())</span>
<span class="fc" id="L1380">					.append( &quot;Could not instantiate a refractor for field [&quot; )</span>
<span class="fc" id="L1381">					.append( fld.getName() )</span>
<span class="fc" id="L1382">					.append( &quot;]:&quot; )</span>
<span class="fc" id="L1383">					.toString(),</span>
				x ) ;
		}
	}

	/**
	 * Extracts the values of all known fields in an object which correspond to
	 * database columns, and returns a {@link ContentValues} instance containing
	 * those values.
	 *
	 * &lt;p&gt;Consumed by {@link #insert} and {@link #update}.&lt;/p&gt;
	 *
	 * @param o the object to be processed.
	 * @return the values that would be stored in the database
	 * @deprecated zerobandwidth-net/android 0.1.7 (#50)
	 */
	@SuppressWarnings({ &quot;unchecked&quot;, &quot;unused&quot; })
	public ContentValues toContentValues( SQLightable o )
	{
<span class="nc" id="L1402">		SQLightable.Reflection tbl = m_mapReflections.get( o.getClass() ) ;</span>
<span class="nc" id="L1403">		return tbl.toContentValues(o) ;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span>Generated by the Android Gradle plugin 2.2.0</div></body></html>