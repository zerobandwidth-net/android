<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SQLightable.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">net.zerobandwidth.android.lib.database.sqlitehouse</a> &gt; <span class="el_source">SQLightable.java</span></div><h1>SQLightable.java</h1><pre class="source lang-java linenums">package net.zerobandwidth.android.lib.database.sqlitehouse;

import android.content.ContentValues;
import android.database.Cursor;
import android.os.Bundle;
import android.util.Log;

import net.zerobandwidth.android.lib.database.querybuilder.DeletionBuilder;
import net.zerobandwidth.android.lib.database.querybuilder.InsertionBuilder;
import net.zerobandwidth.android.lib.database.querybuilder.QueryBuilder;
import net.zerobandwidth.android.lib.database.querybuilder.SelectionBuilder;
import net.zerobandwidth.android.lib.database.querybuilder.UpdateBuilder;
import net.zerobandwidth.android.lib.database.sqlitehouse.annotations.SQLiteColumn;
import net.zerobandwidth.android.lib.database.sqlitehouse.annotations.SQLitePrimaryKey;
import net.zerobandwidth.android.lib.database.sqlitehouse.annotations.SQLiteTable;
import net.zerobandwidth.android.lib.database.sqlitehouse.exceptions.IntrospectionException;
import net.zerobandwidth.android.lib.database.sqlitehouse.exceptions.SchematicException;
import net.zerobandwidth.android.lib.database.sqlitehouse.refractor.NullRefractor;
import net.zerobandwidth.android.lib.database.sqlitehouse.refractor.Refractor;
import net.zerobandwidth.android.lib.database.sqlitehouse.refractor.RefractorMap;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import static net.zerobandwidth.android.lib.database.SQLiteSyntax.SQLITE_NULL;
import static net.zerobandwidth.android.lib.database.SQLiteSyntax.SQLITE_TYPE_INT;
import static net.zerobandwidth.android.lib.database.SQLiteSyntax.SQLITE_TYPE_TEXT;
import static net.zerobandwidth.android.lib.database.SQLiteSyntax.SQL_ADD_COLUMN;
import static net.zerobandwidth.android.lib.database.SQLiteSyntax.SQL_ALTER_TABLE;
import static net.zerobandwidth.android.lib.database.SQLiteSyntax.SQL_COLUMN_DEFAULT;
import static net.zerobandwidth.android.lib.database.SQLiteSyntax.SQL_COLUMN_DEFAULT_NULL;
import static net.zerobandwidth.android.lib.database.SQLiteSyntax.SQL_COLUMN_IS_KEYLIKE;
import static net.zerobandwidth.android.lib.database.SQLiteSyntax.SQL_COLUMN_NOT_NULLABLE;
import static net.zerobandwidth.android.lib.database.SQLiteSyntax.SQL_COLUMN_NULLABLE;
import static net.zerobandwidth.android.lib.database.sqlitehouse.SQLiteHouse.MAGIC_ID_COLUMN_NAME;

/**
 * Designates a class as a data container which can be used in a database
 * defined and managed by {@link SQLiteHouse}. This class must also be decorated
 * by a {@link net.zerobandwidth.android.lib.database.sqlitehouse.annotations.SQLiteTable}
 * annotation which defines the attributes of that table. Implementation classes
 * &lt;b&gt;must&lt;/b&gt; also define a zero-argument constructor in order to be usable by
 * {@link SQLiteHouse#search} or {@link SQLiteHouse#select}.
 * @since zerobandwidth-net/android 0.1.4 (#26)
 */
public interface SQLightable
{
	/**
	 * A full reflection of a {@link SQLightable} object, which represents, and
	 * is used to marshal data for, an SQLite table. Usable by
	 * {@link SQLiteHouse} and any other class that needs to know how this
	 * table class is defined.
	 * @param &lt;T&gt; the class being reflected
	 * @since zerobandwidth-net/android 0.1.7 (#50)
	 */
	class Reflection&lt;T extends SQLightable&gt;
	{
<span class="fc" id="L66">		public static final String LOG_TAG = Reflection.class.getSimpleName() ;</span>

		/**
		 * Obtain a reflection of the specified schematic class.
		 * @param cls the schematic class
		 * @param &lt;ST&gt; the schematic class
		 * @return a reflection of the class
		 */
		public static &lt;ST extends SQLightable&gt; Reflection&lt;ST&gt;
		reflect( Class&lt;ST&gt; cls )
<span class="fc" id="L76">		{ return new Reflection&lt;&gt;( cls ) ; }</span>

		/**
		 * Standardized way to choose the name of a SQLite table based on the
		 * schematic class definition and its annotations, if any.
		 * @param cls the schematic class
		 * @param &lt;ST&gt; the schematic class
		 * @return either the name specified in the annotation, or a lower-cased
		 *  transformation of the class name itself, if the annotation is not
		 *  provided
		 */
		public static &lt;ST extends SQLightable&gt; String
		getTableName( Class&lt;ST&gt; cls )
<span class="fc" id="L89">		{ return getTableName( cls, cls.getAnnotation( SQLiteTable.class ) ) ; }</span>

		/**
		 * Standardized way to choose the name of a SQLite table based on the
		 * annotation attached to the schematic class.
		 * @param cls the schematic class
		 * @param antTable the annotation that describes the table defined by
		 *                 the class (may be null)
		 * @param &lt;ST&gt; the schematic class
		 * @return either the name specified in the annotation, or a lower-cased
		 *  transformation of the class name itself, if the annotation is not
		 *  present
		 * @see #getTableName(Class)
		 * @see #getTableName()
		 */
		protected static &lt;ST extends SQLightable&gt; String getTableName(
				Class&lt;ST&gt; cls, SQLiteTable antTable )
		{
<span class="fc bfc" id="L107" title="All 2 branches covered.">			return ( antTable == null ?</span>
<span class="fc" id="L108">					cls.getSimpleName().toLowerCase() : antTable.value() ) ;</span>
		}

		/**
		 * Shorthand to get an instance of {@link InsertionBuilder} initialized
		 * with the table name that would be reflected for the specified
		 * schematic class. Use this method when you need a query builder but
		 * don't need to retain a copy of the reflection.
		 * @param cls the schematic class
		 * @param &lt;ST&gt; the schematic class
		 * @return a builder for an {@code INSERT} statement
		 */
		public static &lt;ST extends SQLightable&gt; InsertionBuilder
		buildInsert( Class&lt;ST&gt; cls )
<span class="fc" id="L122">		{ return QueryBuilder.insertInto( getTableName(cls) ) ; }</span>

		/**
		 * Shorthand to get an instance of {@link UpdateBuilder} initialized
		 * with the table name that would be reflected for the specified
		 * schematic class. Use this method when you need a query builder but
		 * don't need to retain a copy of the reflection.
		 * @param cls the schematic class
		 * @param &lt;ST&gt; the schematic class
		 * @return a builder for an {@code UPDATE} statement
		 */
		public static &lt;ST extends SQLightable&gt; UpdateBuilder
		buildUpdate( Class&lt;ST&gt; cls )
<span class="fc" id="L135">		{ return QueryBuilder.update( getTableName(cls) ) ; }</span>

		/**
		 * Shorthand to get an instance of {@link SelectionBuilder} initialized
		 * with the table name that would be reflected for the specified
		 * schematic class. Use this method when you need a query builder but
		 * don't need to retain a copy of the reflection.
		 * @param cls the schematic class
		 * @param &lt;ST&gt; the schematic class
		 * @return a builder for a {@code SELECT} statement
		 */
		public static &lt;ST extends SQLightable&gt; SelectionBuilder
		buildSelect( Class&lt;ST&gt; cls )
<span class="fc" id="L148">		{ return QueryBuilder.selectFrom( getTableName(cls) ) ; }</span>

		/**
		 * Shorthand to get an instance of {@link DeletionBuilder} initialized
		 * with the table name that would be reflected for the specified
		 * schematic class. Use this method when you need a query builder but
		 * don't need to retain a copy of the reflection.
		 * @param cls the schematic class
		 * @param &lt;ST&gt; the schematic class
		 * @return a builder for a {@code DELETE} statement
		 */
		public static &lt;ST extends SQLightable&gt; DeletionBuilder
		buildDelete( Class&lt;ST&gt; cls )
<span class="fc" id="L161">		{ return QueryBuilder.deleteFrom( getTableName(cls) ) ; }</span>

		/**
		 * Provides a syntactic shorthand for working with maps of fields to
		 * column reflections.
		 * @since zerobandwidth-net/android 0.1.7 (#50)
		 */
		public static class ColumnMap&lt;ST extends SQLightable&gt;
		extends LinkedHashMap&lt;
				Field, Reflection&lt;ST&gt;.Column &gt;
		{
			public ColumnMap()
<span class="fc" id="L173">			{ super() ; }</span>

			/**
			 * Returns the ordered set of column reflections as a list. This is
			 * provided because using the standard {@link #values()} method
			 * seems to confuse the compiler when used in contexts where the
			 * generic type parameter might be erased.
			 * @return a list of column reflections
			 */
			public List&lt;Reflection&lt;ST&gt;.Column&gt; getColumnsAsList()
			{
<span class="fc" id="L184">				List&lt;Reflection&lt;ST&gt;.Column&gt; aCols</span>
<span class="fc" id="L185">						= new ArrayList&lt;&gt;( this.size() ) ;</span>
<span class="fc" id="L186">				aCols.addAll( this.values() ) ;</span>
<span class="fc" id="L187">				return aCols ;</span>
			}
		}

		/**
		 * A full reflection of a {@link SQLiteColumn} field.
		 * Used by {@link Reflection}.
		 *
		 * Replaces {@code SQLiteHouse#getColumnDefinitionClause(QueryContext)}.
		 *
		 * @since zerobandwidth-net/android 0.1.7 (#50)
		 */
		public class Column
		{
			/** The field that defines the column schema. */
<span class="fc" id="L202">			protected Field m_fldColumn = null ;</span>
			/** The annotation that defines the column schema. */
<span class="fc" id="L204">			protected SQLiteColumn m_antColumn = null ;</span>
			/** Indicates whether the column is also annotated as a key. */
<span class="fc" id="L206">			protected boolean m_bKey = false ;</span>
			/**
			 * The {@link Refractor} implementation to be used for the column.
			 */
<span class="fc" id="L210">			protected Refractor m_lens = null ;</span>

			/**
			 * Initializes the object with the selected field's data.
			 * @param fld the field to be analyzed
			 * @throws SchematicException if the field does not have a
			 *  {@link SQLiteColumn} annotation
			 * @throws IntrospectionException if something goes wrong while
			 *  analyzing the field
			 */
			public Column( Field fld )
			throws SchematicException, IntrospectionException
<span class="fc" id="L222">			{</span>
<span class="fc" id="L223">				m_fldColumn = fld ;</span>
<span class="fc" id="L224">				m_antColumn = fld.getAnnotation( SQLiteColumn.class ) ;</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">				if( m_antColumn == null )</span>
<span class="fc" id="L226">				{ throw SchematicException.fieldNotAnnotated( fld ) ; }</span>
<span class="fc" id="L227">				m_bKey = fld.isAnnotationPresent( SQLitePrimaryKey.class ) ;</span>
<span class="fc" id="L228">				m_lens = this.discoverRefractor() ;</span>
<span class="fc" id="L229">			}</span>

			/**
			 * Discovers the {@link Refractor} implementation to be used for
			 * this column field.
			 * @return the implementation which marshals this field's data
			 * @throws IntrospectionException if the refractor instance can't be
			 *  created
			 * @throws SchematicException if the refractor class can't be
			 *  resolved
			 */
			protected Refractor discoverRefractor()
			throws IntrospectionException, SchematicException
			{
<span class="fc" id="L243">				Class&lt;? extends Refractor&gt; clsLens = m_antColumn.refractor() ;</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">				if( clsLens != NullRefractor.class ) try</span>
				{ // The field explicitly specifies a custom refractor. Use it.
<span class="fc" id="L246">					return clsLens.newInstance() ;</span>
				}
<span class="nc" id="L248">				catch( InstantiationException xInstance )</span>
				{
<span class="nc" id="L250">					throw IntrospectionException</span>
<span class="nc" id="L251">							.instanceFailed( clsLens, xInstance ) ;</span>
				}
<span class="nc" id="L253">				catch( IllegalAccessException xAccess )</span>
				{
<span class="nc" id="L255">					throw IntrospectionException</span>
<span class="nc" id="L256">							.instanceForbidden( clsLens, xAccess ) ;</span>
				}
				// Otherwise, get the standard refractor mapping.
				try
				{
<span class="fc" id="L261">					return RefractorMap.getRefractorFor(m_fldColumn.getType())</span>
<span class="fc" id="L262">							.newInstance() ;</span>
				}
<span class="nc" id="L264">				catch( InstantiationException xInstance )</span>
				{
<span class="nc" id="L266">					throw IntrospectionException</span>
<span class="nc" id="L267">							.instanceFailed( clsLens, xInstance ) ;</span>
				}
<span class="nc" id="L269">				catch( IllegalAccessException xAccess )</span>
				{
<span class="nc" id="L271">					throw IntrospectionException</span>
<span class="nc" id="L272">							.instanceForbidden( clsLens, xAccess ) ;</span>
				}
<span class="fc" id="L274">				catch( NullPointerException xNull )</span>
<span class="fc" id="L275">				{ throw SchematicException.noLensForColumn( this, xNull ) ; }</span>
			}

			/** Accesses the schematic field. */
			public Field getField()
<span class="fc" id="L280">			{ return m_fldColumn ; }</span>

			/** Accesses the schematic annotation. */
			public SQLiteColumn getColAttrs()
<span class="fc" id="L284">			{ return m_antColumn ; }</span>

			/** Indicates whether the column was annotated as a key. */
			public boolean isKey()
<span class="fc" id="L288">			{ return m_bKey ; }</span>

			/** Shorthand to get the DB column name from the annotation. */
			public String getName()
<span class="fc" id="L292">			{ return m_antColumn.name() ; }</span>

			/** Accesses the column's {@link Refractor} implementation. */
			public Refractor getRefractor()
<span class="fc" id="L296">			{ return m_lens ; }</span>

			/**
			 * Generates the SQL clause that will create this column as part of
			 * a {@code CREATE TABLE} or {@code ALTER TABLE ADD COLUMN}
			 * statement.
			 * @return an SQL statement which defines the column
			 */
			public String getColumnCreationClause()
			{
<span class="fc" id="L306">				StringBuilder sb = new StringBuilder() ;</span>

<span class="pc bpc" id="L308" title="1 of 2 branches missed.">				if( m_lens == null )</span>
<span class="nc" id="L309">					throw SchematicException.noLensForColumn( this, null ) ;</span>

<span class="fc" id="L311">				sb.append( this.getName() ).append( &quot; &quot; )</span>
<span class="fc" id="L312">				  .append( m_lens.getSQLiteDataType() )</span>
				  ;
<span class="fc bfc" id="L314" title="All 2 branches covered.">				if( this.isKey() ) // Override the annotation's nullability.</span>
<span class="fc" id="L315">					sb.append( SQL_COLUMN_IS_KEYLIKE ) ;</span>
				else
				{
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">					sb.append(( m_antColumn.is_nullable() ?</span>
							SQL_COLUMN_NULLABLE : SQL_COLUMN_NOT_NULLABLE )) ;
				}
<span class="fc bfc" id="L321" title="All 2 branches covered.">				if( SQLITE_NULL.equals( m_antColumn.sql_default() ) )</span>
				{ // Write &quot;DEFAULT NULL&quot; only if the column is really nullable.
<span class="pc bpc" id="L323" title="1 of 4 branches missed.">					if( ! this.isKey() &amp;&amp; m_antColumn.is_nullable() )</span>
<span class="fc" id="L324">						sb.append( SQL_COLUMN_DEFAULT_NULL ) ;</span>
				}
				else
				{ // Specify the column's default value.
<span class="fc" id="L328">					sb.append( SQL_COLUMN_DEFAULT ) ;</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">					if( SQLITE_TYPE_TEXT.equals( m_lens.getSQLiteDataType() ) )</span>
					{
<span class="fc" id="L331">						sb.append( &quot;'&quot; )</span>
<span class="fc" id="L332">						  .append( m_antColumn.sql_default() )</span>
<span class="fc" id="L333">						  .append( &quot;'&quot; )</span>
						  ;
					}
					else
<span class="fc" id="L337">						sb.append( m_antColumn.sql_default() ) ;</span>
				}

<span class="fc" id="L340">				return sb.toString() ;</span>
			}

			/**
			 * Tries to discover the value of this column within the
			 * corresponding field of an instance of the schematic class that
			 * defines it.
			 * @param o an instance of the schematic class that defined this
			 *          column
			 * @return the SQLite string representation of the value
			 * @throws SchematicException if something goes wrong while trying
			 *  to discover the value
			 */
			public String getSQLColumnValueFrom( T o )
			{
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">				if( o == null )</span>
				{
<span class="nc" id="L357">					throw new IllegalArgumentException(</span>
						&quot;Cannot obtain column value from a null object.&quot; ) ;
				}
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">				if( m_lens == null )</span>
<span class="nc" id="L361">				{ throw SchematicException.noLensForColumn( this, null ) ; }</span>
				try
				{
					//noinspection unchecked
<span class="fc" id="L365">					return m_lens.toSQLiteString(</span>
<span class="fc" id="L366">							m_lens.getValueFrom( o, m_fldColumn ) ) ;</span>
				}
<span class="nc" id="L368">				catch( IllegalAccessException xAccess )</span>
				{
<span class="nc" id="L370">					throw SchematicException.fieldWasInaccessible(</span>
<span class="nc" id="L371">							m_clsTable.getCanonicalName(),</span>
<span class="nc" id="L372">							m_fldColumn.getName(),</span>
							xAccess
						);
				}
			}
		}

		/** The class being reflected. */
		protected Class&lt;T&gt; m_clsTable ;

		/** The annotation on the reflected table class. */
<span class="fc" id="L383">		protected SQLiteTable m_antTable = null ;</span>

		/** The name of the table. Stored once, read repeatedly. */
<span class="fc" id="L386">		protected String m_sTableName = null ;</span>

		/** A map of fields to their column schemas. */
<span class="fc" id="L389">		protected ColumnMap&lt;T&gt; m_mapFields = null ;</span>

		/** A map of DB column names to field definitions. */
<span class="fc" id="L392">		protected HashMap&lt;String,Field&gt; m_mapColNames = null ;</span>

		/** The field that is the primary key for the table. */
<span class="fc" id="L395">		protected Field m_fldKey = null ;</span>

		/**
		 * The field that is the class's placeholder for the magic SQLite
		 * auto-incremented row key, if any.
		 */
<span class="fc" id="L401">		protected Field m_fldMagicID = null ;</span>

		/**
		 * Constructor kicks off a reflection of the selected class.
		 * @param cls the class being reflected
		 * @throws IntrospectionException if something goes wrong
		 */
		public Reflection( Class&lt;T&gt; cls )
		throws IntrospectionException
<span class="fc" id="L410">		{</span>
<span class="fc" id="L411">			m_clsTable = cls ;</span>
<span class="fc" id="L412">			m_antTable = cls.getAnnotation( SQLiteTable.class ) ;</span>
<span class="fc" id="L413">			this.initFieldMap() ;</span>
<span class="fc" id="L414">		}</span>

		/**
		 * Initializes the map of field names to fields.
		 * Consumed by the constructor.
		 * @return (fluid)
		 * @throws IntrospectionException if the column def can't be loaded
		 */
		protected Reflection&lt;T&gt; initFieldMap()
		throws IntrospectionException
		{
<span class="fc" id="L425">			m_mapFields = new ColumnMap&lt;&gt;() ;</span>
<span class="fc" id="L426">			m_mapColNames = new HashMap&lt;&gt;() ;</span>
<span class="fc" id="L427">			List&lt;Field&gt; afldAll =</span>
<span class="fc" id="L428">					Arrays.asList( m_clsTable.getDeclaredFields() ) ;</span>
<span class="fc" id="L429">			ArrayList&lt;Field&gt; afldAnnotated = new ArrayList&lt;&gt;() ;</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">			for( Field fld : afldAll )</span>
			{ // Find only the fields that are annotated as columns.
<span class="fc bfc" id="L432" title="All 2 branches covered.">				if( fld.isAnnotationPresent( SQLiteColumn.class ) )</span>
				{
<span class="fc" id="L434">					fld.setAccessible(true) ;</span>
<span class="fc" id="L435">					afldAnnotated.add(fld) ;</span>
				}
<span class="fc bfc" id="L437" title="All 2 branches covered.">				if( fld.isAnnotationPresent( SQLitePrimaryKey.class ) )</span>
<span class="fc" id="L438">					m_fldKey = fld ;</span>
<span class="fc" id="L439">			}</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">			if( afldAnnotated.size() &gt; 1 )</span>
			{
<span class="fc" id="L442">				Collections.sort( afldAnnotated,</span>
						new SQLiteHouse.ColumnIndexComparator() ) ;
			}
<span class="fc bfc" id="L445" title="All 2 branches covered.">			for( Field fld : afldAnnotated )</span>
			{
<span class="fc" id="L447">				Column col = new Column(fld) ;</span>
<span class="fc" id="L448">				m_mapFields.put( fld, col ) ;</span>
<span class="fc" id="L449">				m_mapColNames.put( col.getName(), fld ) ;</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">				if( SQLiteHouse.MAGIC_ID_COLUMN_NAME.equals( col.getName() ) )</span>
				{ // The class uses this field to marshal the magic ID column.
<span class="fc" id="L452">					m_fldMagicID = fld ;</span>
				}
<span class="fc" id="L454">			}</span>

<span class="fc" id="L456">			return this ;</span>
		}

		/**
		 * Accesses the schematic class reflected in this object.
		 * @return the class reflected in this object
		 */
		public Class&lt;T&gt; getTableClass()
<span class="fc" id="L464">		{ return m_clsTable ; }</span>

		/**
		 * Accesses the {@link SQLiteTable} annotation that defines the
		 * attributes of the table described by this schematic class.
		 * @return the annotation of table attributes
		 */
		public SQLiteTable getTableAttrs()
<span class="fc" id="L472">		{ return m_antTable ; }</span>

		/**
		 * Accesses the name of the database table described by this schematic
		 * class. If the name is not explicitly given in an annotation, then it
		 * will be derived by lower-casing the simple name of the schematic
		 * class itself.
		 * @return the name of the table
		 * @see #getTableName(Class, SQLiteTable)
		 */
		public String getTableName()
		{
<span class="fc bfc" id="L484" title="All 2 branches covered.">			if( m_sTableName == null )</span>
<span class="fc" id="L485">				m_sTableName = getTableName( m_clsTable, m_antTable ) ;</span>
<span class="fc" id="L486">			return m_sTableName ;</span>
		}

		/**
		 * Accesses the field in the schematic class corresponding to the name
		 * of a column in the table described by the class.
		 * @param sColName the name of a column in the database table
		 * @return the field in this schematic class which corresponds to that
		 *  column
		 */
		public Field getField( String sColName )
<span class="fc" id="L497">		{ return m_mapColNames.get(sColName) ; }</span>

		/**
		 * Accesses the complete map of fields and column reflections.
		 * @return the complete map of fields and columns
		 */
		public ColumnMap&lt;T&gt; getColumnMap()
<span class="fc" id="L504">		{ return m_mapFields ; }</span>

		/**
		 * Accesses the SQLite column definition defined by the given field in
		 * the schematic class.
		 * @param fld the field that corresponds to a database table column
		 * @return a reflection of that column
		 */
		public Column getColumnDef( Field fld )
<span class="fc" id="L513">		{ return m_mapFields.get(fld) ; }</span>

		/**
		 * Accesses the SQLite column definition for the given column name.
		 * @param sColName the name of the table column
		 * @return a reflection of that column
		 */
		public Column getColumnDef( String sColName )
<span class="fc" id="L521">		{ return this.getColumnDef( this.getField( sColName ) ) ; }</span>

		/**
		 * Accesses the field that was defined as the practical key for the
		 * table.
		 * @return the field usable as a key
		 */
		public Field getKeyField()
<span class="fc" id="L529">		{ return m_fldKey ; }</span>

		/**
		 * Accesses the column reflection for the field defined as the practical
		 * key for the table.
		 * @return the reflection of the table's key column
		 */
		public Column getKeyColumn()
		{
<span class="fc bfc" id="L538" title="All 2 branches covered.">			return ( this.getKeyField() != null ?</span>
<span class="fc" id="L539">				m_mapFields.get( this.getKeyField() ) : null ) ;</span>
		}

		/**
		 * Accesses the field that was defined as the container for the SQLite
		 * magic auto-incremented row ID, if any.
		 * @return the field which holds the auto-inc row ID
		 */
		public Field getMagicIDField()
<span class="fc" id="L548">		{ return m_fldMagicID ; }</span>

		/**
		 * Accesses the column reflection for the field defined as the container
		 * for the SQLite magic auto-incremented row ID, if any.
		 * @return the reflection of the table's row ID column
		 */
		public Column getMagicIDColumn()
		{
<span class="fc bfc" id="L557" title="All 2 branches covered.">			return ( this.getMagicIDField() != null ?</span>
<span class="fc" id="L558">				m_mapFields.get( this.getMagicIDField() ) : null ) ;</span>
		}

		/**
		 * Tries to find a usable key column, by first looking for a field
		 * defined as the practical key, then looking for a field defined as the
		 * magic auto-incremented row ID, then returning {@code null} if neither
		 * is defined.
		 * @return a column usable as a key, or {@code null} if neither a
		 *  practical key nor a magic row ID column is defined
		 */
		public Column getKeyOrMagicIDColumn()
		{
<span class="fc" id="L571">			Column col = null ;</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">			if( m_fldKey != null )</span>
<span class="fc" id="L573">				col = m_mapFields.get(m_fldKey) ;</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">			else if( m_fldMagicID != null )</span>
<span class="fc" id="L575">				col = m_mapFields.get(m_fldMagicID) ;</span>
<span class="fc" id="L576">			return col ;             // In very rare cases, might still be null.</span>
		}

		/**
		 * Generates the SQL statement which will create the table represented
		 * by this schematic class, based on the class itself, and its
		 * {@link SQLiteTable} annotation (if any).
		 * @return an SQL statement which will create the SQLite table
		 */
		public String getTableCreationSQL()
		{
<span class="fc" id="L587">			StringBuilder sb = new StringBuilder() ;</span>

<span class="fc" id="L589">			sb.append( &quot;CREATE TABLE IF NOT EXISTS &quot; )</span>
<span class="fc" id="L590">			  .append( this.getTableName() )</span>
<span class="fc" id="L591">			  .append( &quot; ( &quot; ).append( MAGIC_ID_COLUMN_NAME )</span>
<span class="fc" id="L592">			  .append( &quot; &quot; ).append( SQLITE_TYPE_INT )</span>
<span class="fc" id="L593">			  .append( &quot; PRIMARY KEY AUTOINCREMENT&quot; )</span>
			  ;

<span class="fc bfc" id="L596" title="All 2 branches covered.">			for( Map.Entry&lt;Field,Reflection&lt;T&gt;.Column&gt; pair : m_mapFields.entrySet() )</span>
			{ // Add the column creation SQL for each schematic field.
<span class="fc" id="L598">				Column col = pair.getValue() ;</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">				if( MAGIC_ID_COLUMN_NAME.equals( col.getName() ) )</span>
<span class="fc" id="L600">					continue ;   // Allow the schematic class to marshal the ID.</span>

<span class="fc" id="L602">				sb.append( &quot;, &quot; )</span>
<span class="fc" id="L603">				  .append( col.getColumnCreationClause() )</span>
				  ;
<span class="fc" id="L605">			}</span>

<span class="fc" id="L607">			sb.append( &quot; )&quot; ) ;</span>

<span class="fc" id="L609">			Log.d( LOG_TAG, sb.toString() ) ; // DEBUG ONLY</span>

<span class="fc" id="L611">			return sb.toString() ;</span>
		}

		/**
		 * Generates the SQL statement which will add the specified column to
		 * this table.
		 * @param col the reflection of the column to be added
		 * @return an SQL statement which adds the column to this table
		 */
		public String getAddColumnSQL( Column col )
		{
			//noinspection StringBufferReplaceableByString
<span class="fc" id="L623">			StringBuilder sb = new StringBuilder() ;</span>
<span class="fc" id="L624">			sb.append( SQL_ALTER_TABLE ).append( this.getTableName() )</span>
<span class="fc" id="L625">			  .append( SQL_ADD_COLUMN )</span>
<span class="fc" id="L626">			  .append( col.getColumnCreationClause() )</span>
			  ;

<span class="fc" id="L629">			Log.d( LOG_TAG, sb.toString() ) ; // DEBUG ONLY</span>

<span class="fc" id="L631">			return sb.toString() ;</span>
		}

		/**
		 * Determines the first version of the schema in which this schematic
		 * class was included. If the {@link SQLiteTable} annotation is missing,
		 * then the method returns {@code 1}.
		 * @return the schema version in which the schematic class was
		 *  introduced
		 */
		public int getFirstSchemaVersion()
		{
<span class="fc bfc" id="L643" title="All 2 branches covered.">			if( m_antTable == null ) return 1 ;</span>
<span class="fc" id="L644">			else return m_antTable.since() ;</span>
		}

		/**
		 * Constructs an empty instance of the {@link SQLightable}
		 * implementation class reflected in this object.
		 * @return an empty instance of the schematic class
		 * @throws IntrospectionException if the schematic class could not be
		 *  constructed for some reason
		 */
		public T getInstance()
		throws IntrospectionException
		{
			try
			{
<span class="fc" id="L659">				Constructor ctor = m_clsTable.getDeclaredConstructor() ;</span>
<span class="pc bpc" id="L660" title="1 of 2 branches missed.">				if( ctor == null ) // try something different</span>
<span class="nc" id="L661">					ctor = m_clsTable.getConstructor() ;</span>
<span class="fc" id="L662">				ctor.setAccessible(true) ;</span>
				//noinspection unchecked - guaranteed
<span class="fc" id="L664">				return ((T)(ctor.newInstance())) ;</span>
			}
<span class="nc" id="L666">			catch( Exception x )</span>
<span class="nc" id="L667">			{ throw IntrospectionException.instanceFailed( m_clsTable, x ) ; }</span>
		}

		/**
		 * Reads a row of data from the specified cursor, and marshals it into a
		 * schematic class instance corresponding to the table from which the
		 * row was fetched.
		 * @param crs the cursor which is currently pointing to a data row
		 * @return an instance of the class, containing the cursor's current row
		 * @throws IntrospectionException if the data class could not be
		 *  constructed for some reason
		 * @throws SchematicException if the data could not be properly
		 *  marshalled into the class instance
		 */
		public T fromCursor( Cursor crs )
		throws IntrospectionException, SchematicException
		{
<span class="fc" id="L684">			T oResult = this.getInstance() ; // Can throw IntrospectionException</span>

<span class="fc" id="L686">			Collection&lt;Column&gt; aColumns = this.getColumnMap().values() ;</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">			for( Column col : aColumns )</span>
			{
				try
				{
<span class="fc" id="L691">					col.getField().set( oResult,</span>
<span class="fc" id="L692">						col.getRefractor().fromCursor( crs, col.getName() ) ) ;</span>
				}
<span class="nc" id="L694">				catch( IllegalAccessException xAccess )</span>
				{
<span class="nc" id="L696">					throw SchematicException.fieldWasInaccessible(</span>
<span class="nc" id="L697">							m_clsTable.getCanonicalName(),</span>
<span class="nc" id="L698">							col.getName(), xAccess</span>
						);
<span class="fc" id="L700">				}</span>
<span class="fc" id="L701">			}</span>

<span class="fc" id="L703">			return oResult ;</span>
		}

		/**
		 * Reads fields from a supplied {@link Bundle}, and marshals it into a
		 * schematic class instance.
		 * @param bndl the bundle into which data was marshalled
		 * @return an instance of the class, containing the bundled data
		 * @throws IntrospectionException if the data class could not be
		 *  constructed for some reason
		 * @throws SchematicException if the data could not be properly
		 *  marshalled into the class instance
		 */
		public T fromBundle( Bundle bndl )
		throws IntrospectionException, SchematicException
		{
<span class="fc" id="L719">			T oResult = this.getInstance() ; // Can throw IntrospectionException</span>

<span class="fc" id="L721">			Collection&lt;Column&gt; aColumns = this.getColumnMap().values() ;</span>
<span class="fc bfc" id="L722" title="All 2 branches covered.">			for( Column col : aColumns )</span>
			{
				try
				{
<span class="fc" id="L726">					col.getField().set( oResult,</span>
<span class="fc" id="L727">						col.getRefractor().fromBundle( bndl, col.getName() ) ) ;</span>
				}
<span class="nc" id="L729">				catch( IllegalAccessException xAccess )</span>
				{
<span class="nc" id="L731">					throw SchematicException.fieldWasInaccessible(</span>
<span class="nc" id="L732">							m_clsTable.getCanonicalName(),</span>
<span class="nc" id="L733">							col.getName(), xAccess</span>
						);
<span class="fc" id="L735">				}</span>
<span class="fc" id="L736">			}</span>

<span class="fc" id="L738">			return oResult ;</span>
		}

		/**
		 * Extracts the values of all known fields, corresponding to database
		 * table columns, from a schematic class instance, and returns a
		 * {@link ContentValues} instance containing those values.
		 *
		 * Replaces {@code SQLiteHouse#toContentValues(SQLightable)}.
		 *
		 * @param oSource the object to be processed
		 * @return the values that would be stored in the database
		 * @throws SchematicException if no {@link Refractor} implementation can
		 *  be found for one of the columns/fields
		 */
		public ContentValues toContentValues( T oSource )
		throws SchematicException
		{
<span class="fc" id="L756">			ContentValues vals = new ContentValues() ;</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">			for( Column col : this.getColumnMap().values() )</span>
			{
<span class="fc" id="L759">				Refractor lens = col.getRefractor() ;</span>

<span class="pc bpc" id="L761" title="1 of 2 branches missed.">				if( lens == null )</span>
<span class="nc" id="L762">					throw SchematicException.noLensForColumn( col, null ) ;</span>

				try
				{
					//noinspection unchecked - lens corresponds to field
<span class="fc" id="L767">					lens.addToContentValues( vals, col.getName(),</span>
<span class="fc" id="L768">							lens.getValueFrom( oSource, col.getField() ) ) ;</span>
				}
<span class="nc" id="L770">				catch( IllegalAccessException xAccess )</span>
				{
<span class="nc" id="L772">					throw SchematicException.fieldWasInaccessible(</span>
<span class="nc" id="L773">							m_clsTable.getCanonicalName(),</span>
<span class="nc" id="L774">							col.getField().getName(),</span>
							xAccess
						);
				}
<span class="nc" id="L778">				catch( SchematicException xSchema )</span>
				{
<span class="nc" id="L780">					Log.e( LOG_TAG, (new StringBuilder())</span>
<span class="nc" id="L781">								.append( &quot;Could not extract value for field [&quot; )</span>
<span class="nc" id="L782">								.append( col.getField().getName() )</span>
<span class="nc" id="L783">								.append( &quot;]:&quot; )</span>
<span class="nc" id="L784">								.toString(),</span>
							xSchema
						);
<span class="fc" id="L787">				} // and continue</span>
<span class="fc" id="L788">			}</span>
<span class="fc" id="L789">			return vals ;</span>
		}

		/**
		 * Extracts the values of all known fields, corresponding to database
		 * table columns, from a schematic class instance, and returns a
		 * {@link Bundle} instance containing those values.
		 * @param oSource the object to be processed
		 * @return the values that would be stored in the database
		 * @throws SchematicException if no {@link Refractor} implementation can
		 *  be found for one of the column's fields
		 */
		public Bundle toBundle( T oSource )
		throws SchematicException
		{
<span class="fc" id="L804">			Bundle bndl = new Bundle() ;</span>
<span class="fc bfc" id="L805" title="All 2 branches covered.">			for( Column col : this.getColumnMap().values() )</span>
			{
<span class="fc" id="L807">				Refractor lens = col.getRefractor() ;</span>

<span class="pc bpc" id="L809" title="1 of 2 branches missed.">				if( lens == null )</span>
<span class="nc" id="L810">					throw SchematicException.noLensForColumn( col, null ) ;</span>

				try
				{
					// noinspection unchecked - lens corresponds to field
<span class="fc" id="L815">					lens.addToBundle( bndl, col.getName(),</span>
<span class="fc" id="L816">							lens.getValueFrom( oSource, col.getField() ) ) ;</span>
				}
<span class="nc" id="L818">				catch( IllegalAccessException xAccess )</span>
				{
<span class="nc" id="L820">					throw SchematicException.fieldWasInaccessible(</span>
<span class="nc" id="L821">							m_clsTable.getCanonicalName(),</span>
<span class="nc" id="L822">							col.getField().getName(),</span>
							xAccess
						);
				}
<span class="nc" id="L826">				catch( SchematicException xSchema )</span>
				{
<span class="nc" id="L828">					Log.e( LOG_TAG, (new StringBuilder())</span>
<span class="nc" id="L829">								.append( &quot;Could not get value for field [&quot; )</span>
<span class="nc" id="L830">								.append( col.getField().getName() )</span>
<span class="nc" id="L831">								.append( &quot;] from a bundle:&quot; )</span>
<span class="nc" id="L832">								.toString(),</span>
							xSchema
						);
<span class="fc" id="L835">				} // and continue</span>
<span class="fc" id="L836">			}</span>
<span class="fc" id="L837">			return bndl ;</span>
		}

		/**
		 * Get an instance of an {@link InsertionBuilder} initialized with the
		 * table name discovered by this reflection.
		 * @return a builder for an {@code INSERT} statement
		 */
		public InsertionBuilder buildInsert()
<span class="fc" id="L846">		{ return QueryBuilder.insertInto( this.getTableName() ) ; }</span>

		/**
		 * Get an instance of an {@link UpdateBuilder} initialized with the
		 * table name discovered by this reflection.
		 * @return a builder for an {@code UPDATE} statement
		 */
		public UpdateBuilder buildUpdate()
<span class="fc" id="L854">		{ return QueryBuilder.update( this.getTableName() ) ; }</span>

		/**
		 * Get an instance of a {@link SelectionBuilder} initialized with the
		 * table name discovered by this reflection.
		 * @return a builder for a {@code SELECT} statement
		 */
		public SelectionBuilder buildSelect()
<span class="fc" id="L862">		{ return QueryBuilder.selectFrom( this.getTableName() ) ; }</span>

		/**
		 * Get an instance of a {@link DeletionBuilder} initialized with the
		 * table name discovered by this reflection.
		 * @return a builder for a {@code DELETE} statement
		 */
		public DeletionBuilder buildDelete()
<span class="fc" id="L870">		{ return QueryBuilder.deleteFrom( this.getTableName() ) ; }</span>
	}

	/**
	 * Provides a precise method for retrieving an entry from a map of schematic
	 * classes to their {@link Reflection} instances.
	 * @since zerobandwidth-net/android 0.1.7 (#50)
	 */
	class ReflectionMap
	extends HashMap&lt; Class&lt;? extends SQLightable&gt;,
			Reflection&lt;? extends SQLightable&gt; &gt;
	{
		public ReflectionMap()
<span class="fc" id="L883">		{ super() ; }</span>

		/**
		 * As {@link Map#get(Object)}, but forces a cast on the
		 * {@link Reflection} object that is returned from the map. This cast is
		 * made unchecked; it is up to the consumer to ensure that the types
		 * match.
		 * @param cls the schematic class
		 * @param &lt;SC&gt; the schematic class
		 * @return a reflection of the schematic class
		 */
		public &lt;SC extends SQLightable&gt; Reflection&lt;SC&gt; get( Class&lt;SC&gt; cls )
		{
			//noinspection unchecked - guaranteed logically
<span class="fc" id="L897">			return ((Reflection&lt;SC&gt;)( super.get(cls) )) ;</span>
		}

		/**
		 * As {@link Map#put(Object,Object)}, but since we can obtain the
		 * {@link Reflection} instance on-the-fly, it is not required.
		 * @param cls the schematic class
		 * @param &lt;SC&gt; the schematic class
		 * @return the previously-mapped reflection, if any
		 */
		public &lt;SC extends SQLightable&gt; Reflection&lt;SC&gt; put( Class&lt;SC&gt; cls )
		{
<span class="pc bpc" id="L909" title="1 of 2 branches missed.">			if( this.containsKey( cls ) )</span>
<span class="nc" id="L910">				return this.get(cls) ;</span>
			else
			{
				//noinspection unchecked - guaranteed logically
<span class="fc" id="L914">				return ((Reflection&lt;SC&gt;)</span>
<span class="fc" id="L915">						( super.put( cls, Reflection.reflect(cls) ) ))  ;</span>
			}
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span>Generated by the Android Gradle plugin 2.2.0</div></body></html>